# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sinatra` gem.
# Please instead update this file by running `bin/tapioca gem sinatra`.

module Rack
  class << self
    # source://rack/2.2.5/lib/rack/version.rb#26
    def release; end

    # source://rack/2.2.5/lib/rack/version.rb#19
    def version; end
  end
end

module Rack::Auth; end

class Rack::Auth::AbstractHandler
  # source://rack/2.2.5/lib/rack/auth/abstract/handler.rb#13
  def initialize(app, realm = T.unsafe(nil), &authenticator); end

  # source://rack/2.2.5/lib/rack/auth/abstract/handler.rb#11
  def realm; end

  # source://rack/2.2.5/lib/rack/auth/abstract/handler.rb#11
  def realm=(_arg0); end

  private

  # source://rack/2.2.5/lib/rack/auth/abstract/handler.rb#29
  def bad_request; end

  # source://rack/2.2.5/lib/rack/auth/abstract/handler.rb#20
  def unauthorized(www_authenticate = T.unsafe(nil)); end
end

class Rack::Auth::AbstractRequest
  # source://rack/2.2.5/lib/rack/auth/abstract/request.rb#7
  def initialize(env); end

  # source://rack/2.2.5/lib/rack/auth/abstract/request.rb#31
  def params; end

  # source://rack/2.2.5/lib/rack/auth/abstract/request.rb#23
  def parts; end

  # source://rack/2.2.5/lib/rack/auth/abstract/request.rb#15
  def provided?; end

  # source://rack/2.2.5/lib/rack/auth/abstract/request.rb#11
  def request; end

  # source://rack/2.2.5/lib/rack/auth/abstract/request.rb#27
  def scheme; end

  # source://rack/2.2.5/lib/rack/auth/abstract/request.rb#19
  def valid?; end

  private

  # source://rack/2.2.5/lib/rack/auth/abstract/request.rb#40
  def authorization_key; end
end

# source://rack/2.2.5/lib/rack/auth/abstract/request.rb#38
Rack::Auth::AbstractRequest::AUTHORIZATION_KEYS = T.let(T.unsafe(nil), Array)

class Rack::Auth::Basic < ::Rack::Auth::AbstractHandler
  # source://rack/2.2.5/lib/rack/auth/basic.rb#18
  def call(env); end

  private

  # source://rack/2.2.5/lib/rack/auth/basic.rb#37
  def challenge; end

  # source://rack/2.2.5/lib/rack/auth/basic.rb#41
  def valid?(auth); end
end

class Rack::Auth::Basic::Request < ::Rack::Auth::AbstractRequest
  # source://rack/2.2.5/lib/rack/auth/basic.rb#46
  def basic?; end

  # source://rack/2.2.5/lib/rack/auth/basic.rb#50
  def credentials; end

  # source://rack/2.2.5/lib/rack/auth/basic.rb#54
  def username; end
end

module Rack::Auth::Digest; end

class Rack::Auth::Digest::MD5 < ::Rack::Auth::AbstractHandler
  # source://rack/2.2.5/lib/rack/auth/digest/md5.rb#26
  def initialize(app, realm = T.unsafe(nil), opaque = T.unsafe(nil), &authenticator); end

  # source://rack/2.2.5/lib/rack/auth/digest/md5.rb#39
  def call(env); end

  # source://rack/2.2.5/lib/rack/auth/digest/md5.rb#22
  def opaque; end

  # source://rack/2.2.5/lib/rack/auth/digest/md5.rb#22
  def opaque=(_arg0); end

  # source://rack/2.2.5/lib/rack/auth/digest/md5.rb#24
  def passwords_hashed=(_arg0); end

  # source://rack/2.2.5/lib/rack/auth/digest/md5.rb#35
  def passwords_hashed?; end

  private

  # source://rack/2.2.5/lib/rack/auth/digest/md5.rb#114
  def A1(auth, password); end

  # source://rack/2.2.5/lib/rack/auth/digest/md5.rb#118
  def A2(auth); end

  # source://rack/2.2.5/lib/rack/auth/digest/md5.rb#104
  def H(data); end

  # source://rack/2.2.5/lib/rack/auth/digest/md5.rb#110
  def KD(secret, data); end

  # source://rack/2.2.5/lib/rack/auth/digest/md5.rb#79
  def challenge(hash = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/auth/digest/md5.rb#122
  def digest(auth, password); end

  # source://rack/2.2.5/lib/rack/auth/digest/md5.rb#104
  def md5(data); end

  # source://rack/2.2.5/lib/rack/auth/digest/md5.rb#68
  def params(hash = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/auth/digest/md5.rb#83
  def valid?(auth); end

  # source://rack/2.2.5/lib/rack/auth/digest/md5.rb#99
  def valid_digest?(auth); end

  # source://rack/2.2.5/lib/rack/auth/digest/md5.rb#95
  def valid_nonce?(auth); end

  # source://rack/2.2.5/lib/rack/auth/digest/md5.rb#91
  def valid_opaque?(auth); end

  # source://rack/2.2.5/lib/rack/auth/digest/md5.rb#87
  def valid_qop?(auth); end
end

# source://rack/2.2.5/lib/rack/auth/digest/md5.rb#66
Rack::Auth::Digest::MD5::QOP = T.let(T.unsafe(nil), String)

class Rack::Auth::Digest::Nonce
  # source://rack/2.2.5/lib/rack/auth/digest/nonce.rb#27
  def initialize(timestamp = T.unsafe(nil), given_digest = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/auth/digest/nonce.rb#35
  def digest; end

  # source://rack/2.2.5/lib/rack/auth/digest/nonce.rb#47
  def fresh?; end

  # source://rack/2.2.5/lib/rack/auth/digest/nonce.rb#43
  def stale?; end

  # source://rack/2.2.5/lib/rack/auth/digest/nonce.rb#31
  def to_s; end

  # source://rack/2.2.5/lib/rack/auth/digest/nonce.rb#39
  def valid?; end

  class << self
    # source://rack/2.2.5/lib/rack/auth/digest/nonce.rb#23
    def parse(string); end

    # source://rack/2.2.5/lib/rack/auth/digest/nonce.rb#20
    def private_key; end

    # source://rack/2.2.5/lib/rack/auth/digest/nonce.rb#20
    def private_key=(_arg0); end

    # source://rack/2.2.5/lib/rack/auth/digest/nonce.rb#20
    def time_limit; end

    # source://rack/2.2.5/lib/rack/auth/digest/nonce.rb#20
    def time_limit=(_arg0); end
  end
end

class Rack::Auth::Digest::Params < ::Hash
  # source://rack/2.2.5/lib/rack/auth/digest/params.rb#25
  def initialize; end

  # source://rack/2.2.5/lib/rack/auth/digest/params.rb#31
  def [](k); end

  # source://rack/2.2.5/lib/rack/auth/digest/params.rb#35
  def []=(k, v); end

  # source://rack/2.2.5/lib/rack/auth/digest/params.rb#47
  def quote(str); end

  # source://rack/2.2.5/lib/rack/auth/digest/params.rb#41
  def to_s; end

  class << self
    # source://rack/2.2.5/lib/rack/auth/digest/params.rb#15
    def dequote(str); end

    # source://rack/2.2.5/lib/rack/auth/digest/params.rb#8
    def parse(str); end

    # source://rack/2.2.5/lib/rack/auth/digest/params.rb#21
    def split_header_value(str); end
  end
end

# source://rack/2.2.5/lib/rack/auth/digest/params.rb#39
Rack::Auth::Digest::Params::UNQUOTED = T.let(T.unsafe(nil), Array)

class Rack::Auth::Digest::Request < ::Rack::Auth::AbstractRequest
  # source://rack/2.2.5/lib/rack/auth/digest/request.rb#19
  def correct_uri?; end

  # source://rack/2.2.5/lib/rack/auth/digest/request.rb#15
  def digest?; end

  # source://rack/2.2.5/lib/rack/auth/digest/request.rb#11
  def method; end

  # source://rack/2.2.5/lib/rack/auth/digest/request.rb#35
  def method_missing(sym, *args); end

  # source://rack/2.2.5/lib/rack/auth/digest/request.rb#23
  def nonce; end

  # source://rack/2.2.5/lib/rack/auth/digest/request.rb#27
  def params; end

  # source://rack/2.2.5/lib/rack/auth/digest/request.rb#31
  def respond_to?(sym, *_arg1); end
end

class Rack::BodyProxy
  # source://rack/2.2.5/lib/rack/body_proxy.rb#10
  def initialize(body, &block); end

  # source://rack/2.2.5/lib/rack/body_proxy.rb#23
  def close; end

  # source://rack/2.2.5/lib/rack/body_proxy.rb#35
  def closed?; end

  # source://rack/2.2.5/lib/rack/body_proxy.rb#40
  def method_missing(method_name, *args, **_arg2, &block); end

  private

  # source://rack/2.2.5/lib/rack/body_proxy.rb#17
  def respond_to_missing?(method_name, include_all = T.unsafe(nil)); end
end

class Rack::Builder
  include ::Sinatra::Delegator

  # source://rack/2.2.5/lib/rack/builder.rb#123
  def initialize(default_app = T.unsafe(nil), &block); end

  # source://rack/2.2.5/lib/rack/builder.rb#243
  def call(env); end

  # source://rack/2.2.5/lib/rack/builder.rb#226
  def freeze_app; end

  # source://rack/2.2.5/lib/rack/builder.rb#219
  def map(path, &block); end

  # source://rack/2.2.5/lib/rack/builder.rb#176
  def run(app); end

  # source://rack/2.2.5/lib/rack/builder.rb#231
  def to_app; end

  # source://rack/2.2.5/lib/rack/builder.rb#153
  def use(middleware, *args, **_arg2, &block); end

  # source://rack/2.2.5/lib/rack/builder.rb#190
  def warmup(prc = T.unsafe(nil), &block); end

  private

  # source://rack/2.2.5/lib/rack/builder.rb#251
  def generate_map(default_app, mapping); end

  class << self
    # source://rack/2.2.5/lib/rack/builder.rb#130
    def app(default_app = T.unsafe(nil), &block); end

    # source://rack/2.2.5/lib/rack/builder.rb#93
    def load_file(path, opts = T.unsafe(nil)); end

    # source://rack/2.2.5/lib/rack/builder.rb#112
    def new_from_string(builder_script, file = T.unsafe(nil)); end

    # source://rack/2.2.5/lib/rack/builder.rb#64
    def parse_file(config, opts = T.unsafe(nil)); end
  end
end

# source://rack/2.2.5/lib/rack/builder.rb#36
Rack::Builder::UTF_8_BOM = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#29
Rack::CACHE_CONTROL = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#31
Rack::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#32
Rack::CONTENT_TYPE = T.let(T.unsafe(nil), String)

class Rack::Cascade
  # source://rack/2.2.5/lib/rack/cascade.rb#22
  def initialize(apps, cascade_for = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/cascade.rb#57
  def <<(app); end

  # source://rack/2.2.5/lib/rack/cascade.rb#57
  def add(app); end

  # source://rack/2.2.5/lib/rack/cascade.rb#14
  def apps; end

  # source://rack/2.2.5/lib/rack/cascade.rb#33
  def call(env); end

  # source://rack/2.2.5/lib/rack/cascade.rb#62
  def include?(app); end
end

# source://rack/2.2.5/lib/rack/cascade.rb#11
Rack::Cascade::NotFound = T.let(T.unsafe(nil), Array)

class Rack::Chunked
  include ::Rack::Utils

  # source://rack/2.2.5/lib/rack/chunked.rb#78
  def initialize(app); end

  # source://rack/2.2.5/lib/rack/chunked.rb#97
  def call(env); end

  # source://rack/2.2.5/lib/rack/chunked.rb#83
  def chunkable_version?(ver); end
end

class Rack::Chunked::Body
  # source://rack/2.2.5/lib/rack/chunked.rb#30
  def initialize(body); end

  # source://rack/2.2.5/lib/rack/chunked.rb#50
  def close; end

  # source://rack/2.2.5/lib/rack/chunked.rb#36
  def each(&block); end

  private

  # source://rack/2.2.5/lib/rack/chunked.rb#57
  def yield_trailers; end
end

# source://rack/2.2.5/lib/rack/chunked.rb#27
Rack::Chunked::Body::TAIL = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack/chunked.rb#26
Rack::Chunked::Body::TERM = T.let(T.unsafe(nil), String)

class Rack::Chunked::TrailerBody < ::Rack::Chunked::Body
  private

  # source://rack/2.2.5/lib/rack/chunked.rb#71
  def yield_trailers; end
end

class Rack::CommonLogger
  # source://rack/2.2.5/lib/rack/common_logger.rb#24
  def initialize(app, logger = T.unsafe(nil)); end

  # source://sinatra//lib/sinatra/base.rb#259
  def call(env); end

  # source://rack/2.2.5/lib/rack/common_logger.rb#36
  def call_without_check(env); end

  private

  # source://rack/2.2.5/lib/rack/common_logger.rb#78
  def extract_content_length(headers); end

  # source://rack/2.2.5/lib/rack/common_logger.rb#47
  def log(env, status, header, began_at); end
end

# source://rack/2.2.5/lib/rack/common_logger.rb#18
Rack::CommonLogger::FORMAT = T.let(T.unsafe(nil), String)

class Rack::ConditionalGet
  # source://rack/2.2.5/lib/rack/conditional_get.rb#18
  def initialize(app); end

  # source://rack/2.2.5/lib/rack/conditional_get.rb#24
  def call(env); end

  private

  # source://rack/2.2.5/lib/rack/conditional_get.rb#59
  def etag_matches?(none_match, headers); end

  # source://rack/2.2.5/lib/rack/conditional_get.rb#48
  def fresh?(env, headers); end

  # source://rack/2.2.5/lib/rack/conditional_get.rb#65
  def modified_since?(modified_since, headers); end

  # source://rack/2.2.5/lib/rack/conditional_get.rb#72
  def to_rfc2822(since); end
end

class Rack::Config
  # source://rack/2.2.5/lib/rack/config.rb#12
  def initialize(app, &block); end

  # source://rack/2.2.5/lib/rack/config.rb#17
  def call(env); end
end

class Rack::ContentLength
  include ::Rack::Utils

  # source://rack/2.2.5/lib/rack/content_length.rb#12
  def initialize(app); end

  # source://rack/2.2.5/lib/rack/content_length.rb#16
  def call(env); end
end

class Rack::ContentType
  include ::Rack::Utils

  # source://rack/2.2.5/lib/rack/content_type.rb#15
  def initialize(app, content_type = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/content_type.rb#19
  def call(env); end
end

# source://rack/2.2.5/lib/rack.rb#43
Rack::DELETE = T.let(T.unsafe(nil), String)

class Rack::Deflater
  # source://rack/2.2.5/lib/rack/deflater.rb#36
  def initialize(app, options = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/deflater.rb#43
  def call(env); end

  private

  # source://rack/2.2.5/lib/rack/deflater.rb#122
  def should_deflate?(env, status, headers, body); end
end

class Rack::Deflater::GzipStream
  # source://rack/2.2.5/lib/rack/deflater.rb#85
  def initialize(body, mtime, sync); end

  # source://rack/2.2.5/lib/rack/deflater.rb#114
  def close; end

  # source://rack/2.2.5/lib/rack/deflater.rb#92
  def each(&block); end

  # source://rack/2.2.5/lib/rack/deflater.rb#109
  def write(data); end
end

class Rack::Directory
  # source://rack/2.2.5/lib/rack/directory.rb#77
  def initialize(root, app = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/directory.rb#83
  def call(env); end

  # source://rack/2.2.5/lib/rack/directory.rb#103
  def check_bad_request(path_info); end

  # source://rack/2.2.5/lib/rack/directory.rb#113
  def check_forbidden(path_info); end

  # source://rack/2.2.5/lib/rack/directory.rb#175
  def entity_not_found(path_info); end

  # source://rack/2.2.5/lib/rack/directory.rb#191
  def filesize_format(int); end

  # source://rack/2.2.5/lib/rack/directory.rb#90
  def get(env); end

  # source://rack/2.2.5/lib/rack/directory.rb#124
  def list_directory(path_info, path, script_name); end

  # source://rack/2.2.5/lib/rack/directory.rb#165
  def list_path(env, path, path_info, script_name); end

  # source://rack/2.2.5/lib/rack/directory.rb#74
  def root; end

  # source://rack/2.2.5/lib/rack/directory.rb#157
  def stat(path); end
end

# source://rack/2.2.5/lib/rack/directory.rb#14
Rack::Directory::DIR_FILE = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack/directory.rb#37
Rack::Directory::DIR_PAGE_FOOTER = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack/directory.rb#15
Rack::Directory::DIR_PAGE_HEADER = T.let(T.unsafe(nil), String)

class Rack::Directory::DirectoryBody < ::Struct
  # source://rack/2.2.5/lib/rack/directory.rb#47
  def each; end

  private

  # source://rack/2.2.5/lib/rack/directory.rb#67
  def DIR_FILE_escape(htmls); end
end

# source://rack/2.2.5/lib/rack/directory.rb#183
Rack::Directory::FILESIZE_FORMAT = T.let(T.unsafe(nil), Array)

# source://rack/2.2.5/lib/rack.rb#36
Rack::ETAG = T.let(T.unsafe(nil), String)

class Rack::ETag
  # source://rack/2.2.5/lib/rack/etag.rb#20
  def initialize(app, no_cache_control = T.unsafe(nil), cache_control = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/etag.rb#26
  def call(env); end

  private

  # source://rack/2.2.5/lib/rack/etag.rb#65
  def digest_body(body); end

  # source://rack/2.2.5/lib/rack/etag.rb#57
  def etag_body?(body); end

  # source://rack/2.2.5/lib/rack/etag.rb#53
  def etag_status?(status); end

  # source://rack/2.2.5/lib/rack/etag.rb#61
  def skip_caching?(headers); end
end

# source://rack/2.2.5/lib/rack/etag.rb#18
Rack::ETag::DEFAULT_CACHE_CONTROL = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack/etag.rb#17
Rack::ETag::ETAG_STRING = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#30
Rack::EXPIRES = T.let(T.unsafe(nil), String)

class Rack::Events
  # source://rack/2.2.5/lib/rack/events.rb#102
  def initialize(app, handlers); end

  # source://rack/2.2.5/lib/rack/events.rb#107
  def call(env); end

  private

  # source://rack/2.2.5/lib/rack/events.rb#145
  def make_request(env); end

  # source://rack/2.2.5/lib/rack/events.rb#149
  def make_response(status, headers, body); end

  # source://rack/2.2.5/lib/rack/events.rb#133
  def on_commit(request, response); end

  # source://rack/2.2.5/lib/rack/events.rb#129
  def on_error(request, response, e); end

  # source://rack/2.2.5/lib/rack/events.rb#141
  def on_finish(request, response); end

  # source://rack/2.2.5/lib/rack/events.rb#137
  def on_start(request, response); end
end

module Rack::Events::Abstract
  # source://rack/2.2.5/lib/rack/events.rb#62
  def on_commit(req, res); end

  # source://rack/2.2.5/lib/rack/events.rb#71
  def on_error(req, res, e); end

  # source://rack/2.2.5/lib/rack/events.rb#68
  def on_finish(req, res); end

  # source://rack/2.2.5/lib/rack/events.rb#65
  def on_send(req, res); end

  # source://rack/2.2.5/lib/rack/events.rb#59
  def on_start(req, res); end
end

class Rack::Events::BufferedResponse < ::Rack::Response::Raw
  # source://rack/2.2.5/lib/rack/events.rb#94
  def initialize(status, headers, body); end

  # source://rack/2.2.5/lib/rack/events.rb#92
  def body; end

  # source://rack/2.2.5/lib/rack/events.rb#99
  def to_a; end
end

class Rack::Events::EventedBodyProxy < ::Rack::BodyProxy
  # source://rack/2.2.5/lib/rack/events.rb#78
  def initialize(body, request, response, handlers, &block); end

  # source://rack/2.2.5/lib/rack/events.rb#85
  def each; end

  # source://rack/2.2.5/lib/rack/events.rb#76
  def request; end

  # source://rack/2.2.5/lib/rack/events.rb#76
  def response; end
end

# source://rack/2.2.5/lib/rack/file.rb#6
Rack::File = Rack::Files

class Rack::Files
  # source://rack/2.2.5/lib/rack/files.rb#29
  def initialize(root, headers = T.unsafe(nil), default_mime = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/files.rb#36
  def call(env); end

  # source://rack/2.2.5/lib/rack/files.rb#41
  def get(env); end

  # source://rack/2.2.5/lib/rack/files.rb#27
  def root; end

  # source://rack/2.2.5/lib/rack/files.rb#70
  def serving(request, path); end

  private

  # source://rack/2.2.5/lib/rack/files.rb#192
  def fail(status, body, headers = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/files.rb#211
  def filesize(path); end

  # source://rack/2.2.5/lib/rack/files.rb#207
  def mime_type(path, default_mime); end

  class << self
    # source://rack/2.2.5/lib/rack/files.rb#20
    def method_added(name); end
  end
end

# source://rack/2.2.5/lib/rack/files.rb#15
Rack::Files::ALLOWED_VERBS = T.let(T.unsafe(nil), Array)

# source://rack/2.2.5/lib/rack/files.rb#16
Rack::Files::ALLOW_HEADER = T.let(T.unsafe(nil), String)

class Rack::Files::BaseIterator
  # source://rack/2.2.5/lib/rack/files.rb#126
  def initialize(path, ranges, options); end

  # source://rack/2.2.5/lib/rack/files.rb#146
  def bytesize; end

  # source://rack/2.2.5/lib/rack/files.rb#155
  def close; end

  # source://rack/2.2.5/lib/rack/files.rb#132
  def each; end

  # source://rack/2.2.5/lib/rack/files.rb#124
  def options; end

  # source://rack/2.2.5/lib/rack/files.rb#124
  def path; end

  # source://rack/2.2.5/lib/rack/files.rb#124
  def ranges; end

  private

  # source://rack/2.2.5/lib/rack/files.rb#173
  def each_range_part(file, range); end

  # source://rack/2.2.5/lib/rack/files.rb#159
  def multipart?; end

  # source://rack/2.2.5/lib/rack/files.rb#163
  def multipart_heading(range); end
end

class Rack::Files::Iterator < ::Rack::Files::BaseIterator
  # source://rack/2.2.5/lib/rack/files.rb#124
  def to_path; end
end

# source://rack/2.2.5/lib/rack/files.rb#17
Rack::Files::MULTIPART_BOUNDARY = T.let(T.unsafe(nil), String)

class Rack::ForwardRequest < ::Exception
  # source://rack/2.2.5/lib/rack/recursive.rb#15
  def initialize(url, env = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/recursive.rb#13
  def env; end

  # source://rack/2.2.5/lib/rack/recursive.rb#13
  def url; end
end

# source://rack/2.2.5/lib/rack.rb#39
Rack::GET = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#44
Rack::HEAD = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#20
Rack::HTTPS = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#35
Rack::HTTP_COOKIE = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#17
Rack::HTTP_HOST = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#18
Rack::HTTP_PORT = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#19
Rack::HTTP_VERSION = T.let(T.unsafe(nil), String)

module Rack::Handler
  class << self
    # source://rack/2.2.5/lib/rack/handler.rb#51
    def default; end

    # source://rack/2.2.5/lib/rack/handler.rb#13
    def get(server); end

    # source://rack/2.2.5/lib/rack/handler.rb#36
    def pick(server_names); end

    # source://rack/2.2.5/lib/rack/handler.rb#85
    def register(server, klass); end

    # source://rack/2.2.5/lib/rack/handler.rb#75
    def try_require(prefix, const_name); end
  end
end

class Rack::Handler::CGI
  class << self
    # source://rack/2.2.5/lib/rack/handler/cgi.rb#6
    def run(app, **options); end

    # source://rack/2.2.5/lib/rack/handler/cgi.rb#51
    def send_body(body); end

    # source://rack/2.2.5/lib/rack/handler/cgi.rb#40
    def send_headers(status, headers); end

    # source://rack/2.2.5/lib/rack/handler/cgi.rb#11
    def serve(app); end
  end
end

class Rack::Handler::WEBrick < ::WEBrick::HTTPServlet::AbstractServlet
  # source://rack/2.2.5/lib/rack/handler/webrick.rb#61
  def initialize(server, app); end

  # source://rack/2.2.5/lib/rack/handler/webrick.rb#66
  def service(req, res); end

  class << self
    # source://rack/2.2.5/lib/rack/handler/webrick.rb#26
    def run(app, **options); end

    # source://rack/2.2.5/lib/rack/handler/webrick.rb#54
    def shutdown; end

    # source://rack/2.2.5/lib/rack/handler/webrick.rb#44
    def valid_options; end
  end
end

class Rack::Head
  # source://rack/2.2.5/lib/rack/head.rb#7
  def initialize(app); end

  # source://rack/2.2.5/lib/rack/head.rb#11
  def call(env); end
end

# source://rack/2.2.5/lib/rack.rb#46
Rack::LINK = T.let(T.unsafe(nil), String)

class Rack::Lint
  include ::Rack::Lint::Assertion

  # source://rack/2.2.5/lib/rack/lint.rb#10
  def initialize(app); end

  # source://rack/2.2.5/lib/rack/lint.rb#41
  def _call(env); end

  # source://rack/2.2.5/lib/rack/lint.rb#37
  def call(env = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/lint.rb#719
  def check_content_length(status, headers); end

  # source://rack/2.2.5/lib/rack/lint.rb#705
  def check_content_type(status, headers); end

  # source://rack/2.2.5/lib/rack/lint.rb#77
  def check_env(env); end

  # source://rack/2.2.5/lib/rack/lint.rb#497
  def check_error(error); end

  # source://rack/2.2.5/lib/rack/lint.rb#668
  def check_headers(header); end

  # source://rack/2.2.5/lib/rack/lint.rb#562
  def check_hijack(env); end

  # source://rack/2.2.5/lib/rack/lint.rb#609
  def check_hijack_response(headers, env); end

  # source://rack/2.2.5/lib/rack/lint.rb#377
  def check_input(input); end

  # source://rack/2.2.5/lib/rack/lint.rb#661
  def check_status(status); end

  # source://rack/2.2.5/lib/rack/lint.rb#792
  def close; end

  # source://rack/2.2.5/lib/rack/lint.rb#745
  def each; end

  # source://rack/2.2.5/lib/rack/lint.rb#732
  def verify_content_length(bytes); end
end

module Rack::Lint::Assertion
  # source://rack/2.2.5/lib/rack/lint.rb#19
  def assert(message); end
end

class Rack::Lint::ErrorWrapper
  include ::Rack::Lint::Assertion

  # source://rack/2.2.5/lib/rack/lint.rb#509
  def initialize(error); end

  # source://rack/2.2.5/lib/rack/lint.rb#531
  def close(*args); end

  # source://rack/2.2.5/lib/rack/lint.rb#526
  def flush; end

  # source://rack/2.2.5/lib/rack/lint.rb#514
  def puts(str); end

  # source://rack/2.2.5/lib/rack/lint.rb#519
  def write(str); end
end

class Rack::Lint::HijackWrapper
  include ::Rack::Lint::Assertion
  extend ::Forwardable

  # source://rack/2.2.5/lib/rack/lint.rb#547
  def initialize(io); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def close(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def close_read(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def close_write(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def closed?(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def flush(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def read(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def read_nonblock(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def write(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def write_nonblock(*args, **_arg1, &block); end
end

# source://rack/2.2.5/lib/rack/lint.rb#540
Rack::Lint::HijackWrapper::REQUIRED_METHODS = T.let(T.unsafe(nil), Array)

class Rack::Lint::InputWrapper
  include ::Rack::Lint::Assertion

  # source://rack/2.2.5/lib/rack/lint.rb#398
  def initialize(input); end

  # source://rack/2.2.5/lib/rack/lint.rb#491
  def close(*args); end

  # source://rack/2.2.5/lib/rack/lint.rb#463
  def each(*args); end

  # source://rack/2.2.5/lib/rack/lint.rb#404
  def gets(*args); end

  # source://rack/2.2.5/lib/rack/lint.rb#430
  def read(*args); end

  # source://rack/2.2.5/lib/rack/lint.rb#478
  def rewind(*args); end
end

class Rack::Lint::LintError < ::RuntimeError; end

class Rack::Lock
  # source://rack/2.2.5/lib/rack/lock.rb#9
  def initialize(app, mutex = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/lock.rb#13
  def call(env); end

  private

  # source://rack/2.2.5/lib/rack/lock.rb#27
  def unlock; end
end

class Rack::Logger
  # source://rack/2.2.5/lib/rack/logger.rb#8
  def initialize(app, level = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/logger.rb#12
  def call(env); end
end

class Rack::MediaType
  class << self
    # source://rack/2.2.5/lib/rack/media_type.rb#26
    def params(content_type); end

    # source://rack/2.2.5/lib/rack/media_type.rb#16
    def type(content_type); end

    private

    # source://rack/2.2.5/lib/rack/media_type.rb#38
    def strip_doublequotes(str); end
  end
end

# source://rack/2.2.5/lib/rack/media_type.rb#7
Rack::MediaType::SPLIT_PATTERN = T.let(T.unsafe(nil), Regexp)

class Rack::MethodOverride
  # source://rack/2.2.5/lib/rack/method_override.rb#11
  def initialize(app); end

  # source://rack/2.2.5/lib/rack/method_override.rb#15
  def call(env); end

  # source://rack/2.2.5/lib/rack/method_override.rb#27
  def method_override(env); end

  private

  # source://rack/2.2.5/lib/rack/method_override.rb#40
  def allowed_methods; end

  # source://rack/2.2.5/lib/rack/method_override.rb#44
  def method_override_param(req); end
end

# source://rack/2.2.5/lib/rack/method_override.rb#9
Rack::MethodOverride::ALLOWED_METHODS = T.let(T.unsafe(nil), Array)

# source://rack/2.2.5/lib/rack/method_override.rb#5
Rack::MethodOverride::HTTP_METHODS = T.let(T.unsafe(nil), Array)

# source://rack/2.2.5/lib/rack/method_override.rb#8
Rack::MethodOverride::HTTP_METHOD_OVERRIDE_HEADER = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack/method_override.rb#7
Rack::MethodOverride::METHOD_OVERRIDE_PARAM_KEY = T.let(T.unsafe(nil), String)

module Rack::Mime
  private

  # source://rack/2.2.5/lib/rack/mime.rb#30
  def match?(value, matcher); end

  # source://rack/2.2.5/lib/rack/mime.rb#18
  def mime_type(ext, fallback = T.unsafe(nil)); end

  class << self
    # source://rack/2.2.5/lib/rack/mime.rb#30
    def match?(value, matcher); end

    # source://rack/2.2.5/lib/rack/mime.rb#18
    def mime_type(ext, fallback = T.unsafe(nil)); end
  end
end

# source://rack/2.2.5/lib/rack/mime.rb#51
Rack::Mime::MIME_TYPES = T.let(T.unsafe(nil), Hash)

class Rack::MockRequest
  # source://rack/2.2.5/lib/rack/mock.rb#52
  def initialize(app); end

  # source://rack/2.2.5/lib/rack/mock.rb#65
  def delete(uri, opts = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/mock.rb#57
  def get(uri, opts = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/mock.rb#67
  def head(uri, opts = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/mock.rb#69
  def options(uri, opts = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/mock.rb#63
  def patch(uri, opts = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/mock.rb#59
  def post(uri, opts = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/mock.rb#61
  def put(uri, opts = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/mock.rb#74
  def request(method = T.unsafe(nil), uri = T.unsafe(nil), opts = T.unsafe(nil)); end

  class << self
    # source://rack/2.2.5/lib/rack/mock.rb#105
    def env_for(uri = T.unsafe(nil), opts = T.unsafe(nil)); end

    # source://rack/2.2.5/lib/rack/mock.rb#92
    def parse_uri_rfc2396(uri); end
  end
end

# source://rack/2.2.5/lib/rack/mock.rb#43
Rack::MockRequest::DEFAULT_ENV = T.let(T.unsafe(nil), Hash)

class Rack::MockRequest::FatalWarner
  # source://rack/2.2.5/lib/rack/mock.rb#35
  def flush; end

  # source://rack/2.2.5/lib/rack/mock.rb#27
  def puts(warning); end

  # source://rack/2.2.5/lib/rack/mock.rb#38
  def string; end

  # source://rack/2.2.5/lib/rack/mock.rb#31
  def write(warning); end
end

class Rack::MockRequest::FatalWarning < ::RuntimeError; end

class Rack::MockResponse < ::Rack::Response
  # source://rack/2.2.5/lib/rack/mock.rb#184
  def initialize(status, headers, body, errors = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/mock.rb#194
  def =~(other); end

  # source://rack/2.2.5/lib/rack/mock.rb#202
  def body; end

  # source://rack/2.2.5/lib/rack/mock.rb#226
  def cookie(name); end

  # source://rack/2.2.5/lib/rack/mock.rb#179
  def cookies; end

  # source://rack/2.2.5/lib/rack/mock.rb#222
  def empty?; end

  # source://rack/2.2.5/lib/rack/mock.rb#182
  def errors; end

  # source://rack/2.2.5/lib/rack/mock.rb#182
  def errors=(_arg0); end

  # source://rack/2.2.5/lib/rack/mock.rb#198
  def match(other); end

  # source://rack/2.2.5/lib/rack/mock.rb#179
  def original_headers; end

  private

  # source://rack/2.2.5/lib/rack/mock.rb#253
  def identify_cookie_attributes(cookie_filling); end

  # source://rack/2.2.5/lib/rack/mock.rb#232
  def parse_cookies_from_header; end

  class << self
    def [](*_arg0); end
  end
end

module Rack::Multipart
  class << self
    # source://rack/2.2.5/lib/rack/multipart.rb#58
    def build_multipart(params, first = T.unsafe(nil)); end

    # source://rack/2.2.5/lib/rack/multipart.rb#44
    def extract_multipart(req, params = T.unsafe(nil)); end

    # source://rack/2.2.5/lib/rack/multipart.rb#40
    def parse_multipart(env, params = T.unsafe(nil)); end
  end
end

# source://rack/2.2.5/lib/rack/multipart.rb#25
Rack::Multipart::ATTRIBUTE = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.5/lib/rack/multipart.rb#24
Rack::Multipart::ATTRIBUTE_CHAR = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.5/lib/rack/multipart.rb#19
Rack::Multipart::BROKEN = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.5/lib/rack/multipart.rb#17
Rack::Multipart::CONDISP = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.5/lib/rack/multipart.rb#36
Rack::Multipart::DISPPARM = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.5/lib/rack/multipart.rb#13
Rack::Multipart::EOL = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack/multipart.rb#32
Rack::Multipart::EXTENDED_INITIAL_NAME = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.5/lib/rack/multipart.rb#34
Rack::Multipart::EXTENDED_INITIAL_PARAMETER = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.5/lib/rack/multipart.rb#33
Rack::Multipart::EXTENDED_INITIAL_VALUE = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.5/lib/rack/multipart.rb#29
Rack::Multipart::EXTENDED_OTHER_NAME = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.5/lib/rack/multipart.rb#31
Rack::Multipart::EXTENDED_OTHER_PARAMETER = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.5/lib/rack/multipart.rb#30
Rack::Multipart::EXTENDED_OTHER_VALUE = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.5/lib/rack/multipart.rb#35
Rack::Multipart::EXTENDED_PARAMETER = T.let(T.unsafe(nil), Regexp)

class Rack::Multipart::Generator
  # source://rack/2.2.5/lib/rack/multipart/generator.rb#6
  def initialize(params, first = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/multipart/generator.rb#14
  def dump; end

  private

  # source://rack/2.2.5/lib/rack/multipart/generator.rb#87
  def content_for_other(file, name); end

  # source://rack/2.2.5/lib/rack/multipart/generator.rb#75
  def content_for_tempfile(io, file, name); end

  # source://rack/2.2.5/lib/rack/multipart/generator.rb#50
  def flattened_params; end

  # source://rack/2.2.5/lib/rack/multipart/generator.rb#35
  def multipart?; end
end

# source://rack/2.2.5/lib/rack/multipart.rb#15
Rack::Multipart::MULTIPART = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.5/lib/rack/multipart.rb#14
Rack::Multipart::MULTIPART_BOUNDARY = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack/multipart.rb#21
Rack::Multipart::MULTIPART_CONTENT_DISPOSITION = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.5/lib/rack/multipart.rb#22
Rack::Multipart::MULTIPART_CONTENT_ID = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.5/lib/rack/multipart.rb#20
Rack::Multipart::MULTIPART_CONTENT_TYPE = T.let(T.unsafe(nil), Regexp)

class Rack::Multipart::MultipartPartLimitError < ::Errno::EMFILE; end

class Rack::Multipart::Parser
  # source://rack/2.2.5/lib/rack/multipart/parser.rb#167
  def initialize(boundary, tempfile, bufsize, query_parser); end

  # source://rack/2.2.5/lib/rack/multipart/parser.rb#185
  def on_read(content); end

  # source://rack/2.2.5/lib/rack/multipart/parser.rb#191
  def result; end

  # source://rack/2.2.5/lib/rack/multipart/parser.rb#165
  def state; end

  private

  # source://rack/2.2.5/lib/rack/multipart/parser.rb#283
  def consume_boundary; end

  # source://rack/2.2.5/lib/rack/multipart/parser.rb#281
  def full_boundary; end

  # source://rack/2.2.5/lib/rack/multipart/parser.rb#293
  def get_filename(head); end

  # source://rack/2.2.5/lib/rack/multipart/parser.rb#229
  def handle_consume_token; end

  # source://rack/2.2.5/lib/rack/multipart/parser.rb#358
  def handle_empty_content!(content); end

  # source://rack/2.2.5/lib/rack/multipart/parser.rb#220
  def handle_fast_forward; end

  # source://rack/2.2.5/lib/rack/multipart/parser.rb#262
  def handle_mime_body; end

  # source://rack/2.2.5/lib/rack/multipart/parser.rb#239
  def handle_mime_head; end

  # source://rack/2.2.5/lib/rack/multipart/parser.rb#203
  def run_parser; end

  # source://rack/2.2.5/lib/rack/multipart/parser.rb#330
  def tag_multipart_encoding(filename, content_type, name, body); end

  class << self
    # source://rack/2.2.5/lib/rack/multipart/parser.rb#63
    def parse(io, content_length, content_type, tmpfile, bufsize, qp); end

    # source://rack/2.2.5/lib/rack/multipart/parser.rb#56
    def parse_boundary(content_type); end
  end
end

# source://rack/2.2.5/lib/rack/multipart/parser.rb#18
Rack::Multipart::Parser::BOUNDARY_REGEX = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.5/lib/rack/multipart/parser.rb#12
Rack::Multipart::Parser::BUFSIZE = T.let(T.unsafe(nil), Integer)

class Rack::Multipart::Parser::BoundedIO
  # source://rack/2.2.5/lib/rack/multipart/parser.rb#21
  def initialize(io, content_length); end

  # source://rack/2.2.5/lib/rack/multipart/parser.rb#27
  def read(size, outbuf = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/multipart/parser.rb#48
  def rewind; end
end

# source://rack/2.2.5/lib/rack/multipart/parser.rb#328
Rack::Multipart::Parser::CHARSET = T.let(T.unsafe(nil), String)

class Rack::Multipart::Parser::Collector
  include ::Enumerable

  # source://rack/2.2.5/lib/rack/multipart/parser.rb#120
  def initialize(tempfile); end

  # source://rack/2.2.5/lib/rack/multipart/parser.rb#126
  def each; end

  # source://rack/2.2.5/lib/rack/multipart/parser.rb#146
  def on_mime_body(mime_index, content); end

  # source://rack/2.2.5/lib/rack/multipart/parser.rb#150
  def on_mime_finish(mime_index); end

  # source://rack/2.2.5/lib/rack/multipart/parser.rb#130
  def on_mime_head(mime_index, head, filename, content_type, name); end

  private

  # source://rack/2.2.5/lib/rack/multipart/parser.rb#155
  def check_open_files; end
end

class Rack::Multipart::Parser::Collector::BufferPart < ::Rack::Multipart::Parser::Collector::MimePart
  # source://rack/2.2.5/lib/rack/multipart/parser.rb#110
  def close; end

  # source://rack/2.2.5/lib/rack/multipart/parser.rb#109
  def file?; end
end

class Rack::Multipart::Parser::Collector::MimePart < ::Struct
  # source://rack/2.2.5/lib/rack/multipart/parser.rb#86
  def get_data; end
end

class Rack::Multipart::Parser::Collector::TempfilePart < ::Rack::Multipart::Parser::Collector::MimePart
  # source://rack/2.2.5/lib/rack/multipart/parser.rb#115
  def close; end

  # source://rack/2.2.5/lib/rack/multipart/parser.rb#114
  def file?; end
end

# source://rack/2.2.5/lib/rack/multipart/parser.rb#54
Rack::Multipart::Parser::EMPTY = T.let(T.unsafe(nil), Rack::Multipart::Parser::MultipartInfo)

class Rack::Multipart::Parser::MultipartInfo < ::Struct
  def params; end
  def params=(_); end
  def tmp_files; end
  def tmp_files=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://rack/2.2.5/lib/rack/multipart/parser.rb#14
Rack::Multipart::Parser::TEMPFILE_FACTORY = T.let(T.unsafe(nil), Proc)

# source://rack/2.2.5/lib/rack/multipart/parser.rb#13
Rack::Multipart::Parser::TEXT_PLAIN = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack/multipart.rb#28
Rack::Multipart::REGULAR_PARAMETER = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.5/lib/rack/multipart.rb#27
Rack::Multipart::REGULAR_PARAMETER_NAME = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.5/lib/rack/multipart.rb#37
Rack::Multipart::RFC2183 = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.5/lib/rack/multipart.rb#26
Rack::Multipart::SECTION = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.5/lib/rack/multipart.rb#16
Rack::Multipart::TOKEN = T.let(T.unsafe(nil), Regexp)

class Rack::Multipart::UploadedFile
  # source://rack/2.2.5/lib/rack/multipart/uploaded_file.rb#12
  def initialize(filepath = T.unsafe(nil), ct = T.unsafe(nil), bin = T.unsafe(nil), path: T.unsafe(nil), content_type: T.unsafe(nil), binary: T.unsafe(nil), filename: T.unsafe(nil), io: T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/multipart/uploaded_file.rb#10
  def content_type; end

  # source://rack/2.2.5/lib/rack/multipart/uploaded_file.rb#10
  def content_type=(_arg0); end

  # source://rack/2.2.5/lib/rack/multipart/uploaded_file.rb#27
  def local_path; end

  # source://rack/2.2.5/lib/rack/multipart/uploaded_file.rb#36
  def method_missing(method_name, *args, &block); end

  # source://rack/2.2.5/lib/rack/multipart/uploaded_file.rb#7
  def original_filename; end

  # source://rack/2.2.5/lib/rack/multipart/uploaded_file.rb#27
  def path; end

  # source://rack/2.2.5/lib/rack/multipart/uploaded_file.rb#32
  def respond_to?(*args); end
end

# source://rack/2.2.5/lib/rack/multipart.rb#18
Rack::Multipart::VALUE = T.let(T.unsafe(nil), Regexp)

class Rack::NullLogger
  # source://rack/2.2.5/lib/rack/null_logger.rb#5
  def initialize(app); end

  # source://rack/2.2.5/lib/rack/null_logger.rb#37
  def <<(msg); end

  # source://rack/2.2.5/lib/rack/null_logger.rb#36
  def add(severity, message = T.unsafe(nil), progname = T.unsafe(nil), &block); end

  # source://rack/2.2.5/lib/rack/null_logger.rb#9
  def call(env); end

  # source://rack/2.2.5/lib/rack/null_logger.rb#35
  def close; end

  # source://rack/2.2.5/lib/rack/null_logger.rb#27
  def datetime_format; end

  # source://rack/2.2.5/lib/rack/null_logger.rb#32
  def datetime_format=(datetime_format); end

  # source://rack/2.2.5/lib/rack/null_logger.rb#15
  def debug(progname = T.unsafe(nil), &block); end

  # source://rack/2.2.5/lib/rack/null_logger.rb#21
  def debug?; end

  # source://rack/2.2.5/lib/rack/null_logger.rb#17
  def error(progname = T.unsafe(nil), &block); end

  # source://rack/2.2.5/lib/rack/null_logger.rb#23
  def error?; end

  # source://rack/2.2.5/lib/rack/null_logger.rb#18
  def fatal(progname = T.unsafe(nil), &block); end

  # source://rack/2.2.5/lib/rack/null_logger.rb#24
  def fatal?; end

  # source://rack/2.2.5/lib/rack/null_logger.rb#28
  def formatter; end

  # source://rack/2.2.5/lib/rack/null_logger.rb#33
  def formatter=(formatter); end

  # source://rack/2.2.5/lib/rack/null_logger.rb#14
  def info(progname = T.unsafe(nil), &block); end

  # source://rack/2.2.5/lib/rack/null_logger.rb#20
  def info?; end

  # source://rack/2.2.5/lib/rack/null_logger.rb#25
  def level; end

  # source://rack/2.2.5/lib/rack/null_logger.rb#30
  def level=(level); end

  # source://rack/2.2.5/lib/rack/null_logger.rb#26
  def progname; end

  # source://rack/2.2.5/lib/rack/null_logger.rb#31
  def progname=(progname); end

  # source://rack/2.2.5/lib/rack/null_logger.rb#29
  def sev_threshold; end

  # source://rack/2.2.5/lib/rack/null_logger.rb#34
  def sev_threshold=(sev_threshold); end

  # source://rack/2.2.5/lib/rack/null_logger.rb#19
  def unknown(progname = T.unsafe(nil), &block); end

  # source://rack/2.2.5/lib/rack/null_logger.rb#16
  def warn(progname = T.unsafe(nil), &block); end

  # source://rack/2.2.5/lib/rack/null_logger.rb#22
  def warn?; end
end

# source://rack/2.2.5/lib/rack.rb#45
Rack::OPTIONS = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#42
Rack::PATCH = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#21
Rack::PATH_INFO = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#40
Rack::POST = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#41
Rack::PUT = T.let(T.unsafe(nil), String)

module Rack::Protection
  class << self
    # source://rack-protection/3.0.5/lib/rack/protection.rb#28
    def new(app, options = T.unsafe(nil)); end
  end
end

class Rack::Protection::AuthenticityToken < ::Rack::Protection::Base
  # source://rack-protection/3.0.5/lib/rack/protection/authenticity_token.rb#112
  def accepts?(env); end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#24
  def default_options; end

  # source://rack-protection/3.0.5/lib/rack/protection/authenticity_token.rb#124
  def mask_authenticity_token(session, path: T.unsafe(nil), method: T.unsafe(nil)); end

  private

  # source://rack-protection/3.0.5/lib/rack/protection/authenticity_token.rb#206
  def compare_with_global_token(token, session); end

  # source://rack-protection/3.0.5/lib/rack/protection/authenticity_token.rb#210
  def compare_with_per_form_token(token, session, request); end

  # source://rack-protection/3.0.5/lib/rack/protection/authenticity_token.rb#202
  def compare_with_real_token(token, session); end

  # source://rack-protection/3.0.5/lib/rack/protection/authenticity_token.rb#231
  def decode_token(token); end

  # source://rack-protection/3.0.5/lib/rack/protection/authenticity_token.rb#227
  def encode_token(token); end

  # source://rack-protection/3.0.5/lib/rack/protection/authenticity_token.rb#219
  def global_token(session); end

  # source://rack-protection/3.0.5/lib/rack/protection/authenticity_token.rb#177
  def mask_token(token); end

  # source://rack-protection/3.0.5/lib/rack/protection/authenticity_token.rb#198
  def masked_token?(token); end

  # source://rack-protection/3.0.5/lib/rack/protection/authenticity_token.rb#223
  def per_form_token(session, path, method); end

  # source://rack-protection/3.0.5/lib/rack/protection/authenticity_token.rb#215
  def real_token(session); end

  # source://rack-protection/3.0.5/lib/rack/protection/authenticity_token.rb#141
  def set_token(session); end

  # source://rack-protection/3.0.5/lib/rack/protection/authenticity_token.rb#235
  def token_hmac(session, identifier); end

  # source://rack-protection/3.0.5/lib/rack/protection/authenticity_token.rb#185
  def unmask_token(masked_token); end

  # source://rack-protection/3.0.5/lib/rack/protection/authenticity_token.rb#194
  def unmasked_token?(token); end

  # source://rack-protection/3.0.5/lib/rack/protection/authenticity_token.rb#147
  def valid_token?(env, token); end

  # source://rack-protection/3.0.5/lib/rack/protection/authenticity_token.rb#243
  def xor_byte_strings(s1, s2); end

  class << self
    # source://rack-protection/3.0.5/lib/rack/protection/authenticity_token.rb#108
    def random_token; end

    # source://rack-protection/3.0.5/lib/rack/protection/authenticity_token.rb#104
    def token(session, path: T.unsafe(nil), method: T.unsafe(nil)); end
  end
end

# source://rack-protection/3.0.5/lib/rack/protection/authenticity_token.rb#98
Rack::Protection::AuthenticityToken::TOKEN_LENGTH = T.let(T.unsafe(nil), Integer)

class Rack::Protection::Base
  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#35
  def initialize(app, options = T.unsafe(nil)); end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#44
  def accepts?(env); end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#21
  def app; end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#48
  def call(env); end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#31
  def default_options; end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#75
  def default_reaction(env); end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#75
  def deny(env); end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#95
  def drop_session(env); end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#117
  def encrypt(value); end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#127
  def html?(headers); end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#68
  def instrument(env); end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#21
  def options; end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#107
  def origin(env); end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#111
  def random_string(secure = T.unsafe(nil)); end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#56
  def react(env); end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#99
  def referrer(env); end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#80
  def report(env); end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#40
  def safe?(env); end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#121
  def secure_compare(a, b); end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#89
  def session(env); end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#85
  def session?(env); end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#61
  def warn(env, message); end

  class << self
    # source://rack-protection/3.0.5/lib/rack/protection/base.rb#23
    def default_options(options); end

    # source://rack-protection/3.0.5/lib/rack/protection/base.rb#27
    def default_reaction(reaction); end
  end
end

# source://rack-protection/3.0.5/lib/rack/protection/base.rb#12
Rack::Protection::Base::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

class Rack::Protection::ContentSecurityPolicy < ::Rack::Protection::Base
  # source://rack-protection/3.0.5/lib/rack/protection/content_security_policy.rb#72
  def call(env); end

  # source://rack-protection/3.0.5/lib/rack/protection/content_security_policy.rb#53
  def csp_policy; end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#24
  def default_options; end
end

# source://rack-protection/3.0.5/lib/rack/protection/content_security_policy.rb#42
Rack::Protection::ContentSecurityPolicy::DIRECTIVES = T.let(T.unsafe(nil), Array)

# source://rack-protection/3.0.5/lib/rack/protection/content_security_policy.rb#50
Rack::Protection::ContentSecurityPolicy::NO_ARG_DIRECTIVES = T.let(T.unsafe(nil), Array)

class Rack::Protection::CookieTossing < ::Rack::Protection::Base
  # source://rack-protection/3.0.5/lib/rack/protection/cookie_tossing.rb#30
  def accepts?(env); end

  # source://rack-protection/3.0.5/lib/rack/protection/cookie_tossing.rb#57
  def bad_cookies; end

  # source://rack-protection/3.0.5/lib/rack/protection/cookie_tossing.rb#22
  def call(env); end

  # source://rack-protection/3.0.5/lib/rack/protection/cookie_tossing.rb#61
  def cookie_paths(path); end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#75
  def default_reaction(env); end

  # source://rack-protection/3.0.5/lib/rack/protection/cookie_tossing.rb#68
  def empty_cookie(host, path); end

  # source://rack-protection/3.0.5/lib/rack/protection/cookie_tossing.rb#51
  def redirect(env); end

  # source://rack-protection/3.0.5/lib/rack/protection/cookie_tossing.rb#42
  def remove_bad_cookies(request, response); end

  # source://rack-protection/3.0.5/lib/rack/protection/cookie_tossing.rb#72
  def session_key; end
end

class Rack::Protection::EncryptedCookie < ::Rack::Session::Abstract::Persisted
  # source://rack-protection/3.0.5/lib/rack/protection/encrypted_cookie.rb#143
  def initialize(app, options = T.unsafe(nil)); end

  # source://rack-protection/3.0.5/lib/rack/protection/encrypted_cookie.rb#141
  def coder; end

  private

  # source://rack-protection/3.0.5/lib/rack/protection/encrypted_cookie.rb#252
  def delete_session(_req, _session_id, options); end

  # source://rack-protection/3.0.5/lib/rack/protection/encrypted_cookie.rb#257
  def digest_match?(data, digest); end

  # source://rack-protection/3.0.5/lib/rack/protection/encrypted_cookie.rb#200
  def extract_session_id(request); end

  # source://rack-protection/3.0.5/lib/rack/protection/encrypted_cookie.rb#194
  def find_session(req, _sid); end

  # source://rack-protection/3.0.5/lib/rack/protection/encrypted_cookie.rb#263
  def generate_hmac(data); end

  # source://rack-protection/3.0.5/lib/rack/protection/encrypted_cookie.rb#230
  def persistent_session_id!(data, sid = T.unsafe(nil)); end

  # source://rack-protection/3.0.5/lib/rack/protection/encrypted_cookie.rb#267
  def secure?(options); end

  # source://rack-protection/3.0.5/lib/rack/protection/encrypted_cookie.rb#204
  def unpacked_cookie_data(request); end

  # source://rack-protection/3.0.5/lib/rack/protection/encrypted_cookie.rb#236
  def write_session(req, session_id, session, _options); end
end

class Rack::Protection::EncryptedCookie::Base64
  # source://rack-protection/3.0.5/lib/rack/protection/encrypted_cookie.rb#71
  def decode(str); end

  # source://rack-protection/3.0.5/lib/rack/protection/encrypted_cookie.rb#67
  def encode(str); end
end

class Rack::Protection::EncryptedCookie::Base64::JSON < ::Rack::Protection::EncryptedCookie::Base64
  # source://rack-protection/3.0.5/lib/rack/protection/encrypted_cookie.rb#99
  def decode(str); end

  # source://rack-protection/3.0.5/lib/rack/protection/encrypted_cookie.rb#95
  def encode(obj); end
end

class Rack::Protection::EncryptedCookie::Base64::Marshal < ::Rack::Protection::EncryptedCookie::Base64
  # source://rack-protection/3.0.5/lib/rack/protection/encrypted_cookie.rb#81
  def decode(str); end

  # source://rack-protection/3.0.5/lib/rack/protection/encrypted_cookie.rb#77
  def encode(str); end
end

class Rack::Protection::EncryptedCookie::Base64::ZipJSON < ::Rack::Protection::EncryptedCookie::Base64
  # source://rack-protection/3.0.5/lib/rack/protection/encrypted_cookie.rb#115
  def decode(str); end

  # source://rack-protection/3.0.5/lib/rack/protection/encrypted_cookie.rb#111
  def encode(obj); end
end

class Rack::Protection::EncryptedCookie::Identity
  # source://rack-protection/3.0.5/lib/rack/protection/encrypted_cookie.rb#128
  def decode(str); end

  # source://rack-protection/3.0.5/lib/rack/protection/encrypted_cookie.rb#127
  def encode(str); end
end

class Rack::Protection::EncryptedCookie::Marshal
  # source://rack-protection/3.0.5/lib/rack/protection/encrypted_cookie.rb#136
  def decode(str); end

  # source://rack-protection/3.0.5/lib/rack/protection/encrypted_cookie.rb#132
  def encode(str); end
end

module Rack::Protection::Encryptor
  class << self
    # source://rack-protection/3.0.5/lib/rack/protection/encryptor.rb#15
    def base64_decode(str); end

    # source://rack-protection/3.0.5/lib/rack/protection/encryptor.rb#11
    def base64_encode(str); end

    # source://rack-protection/3.0.5/lib/rack/protection/encryptor.rb#38
    def decrypt_message(data, secret); end

    # source://rack-protection/3.0.5/lib/rack/protection/encryptor.rb#19
    def encrypt_message(data, secret, auth_data = T.unsafe(nil)); end
  end
end

# source://rack-protection/3.0.5/lib/rack/protection/encryptor.rb#8
Rack::Protection::Encryptor::CIPHER = T.let(T.unsafe(nil), String)

# source://rack-protection/3.0.5/lib/rack/protection/encryptor.rb#9
Rack::Protection::Encryptor::DELIMITER = T.let(T.unsafe(nil), String)

class Rack::Protection::EscapedParams < ::Rack::Protection::Base
  extend ::Rack::Utils

  # source://rack-protection/3.0.5/lib/rack/protection/escaped_params.rb#36
  def initialize(*_arg0); end

  # source://rack-protection/3.0.5/lib/rack/protection/escaped_params.rb#50
  def call(env); end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#24
  def default_options; end

  # source://rack-protection/3.0.5/lib/rack/protection/escaped_params.rb#70
  def escape(object); end

  # source://rack-protection/3.0.5/lib/rack/protection/escaped_params.rb#79
  def escape_hash(hash); end

  # source://rack-protection/3.0.5/lib/rack/protection/escaped_params.rb#85
  def escape_string(str); end

  # source://rack-protection/3.0.5/lib/rack/protection/escaped_params.rb#64
  def handle(hash); end

  class << self
    private

    # source://rack/2.2.5/lib/rack/utils.rb#38
    def escape_url(s); end
  end
end

class Rack::Protection::FormToken < ::Rack::Protection::AuthenticityToken
  # source://rack-protection/3.0.5/lib/rack/protection/form_token.rb#20
  def accepts?(env); end
end

class Rack::Protection::FrameOptions < ::Rack::Protection::Base
  # source://rack-protection/3.0.5/lib/rack/protection/frame_options.rb#32
  def call(env); end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#24
  def default_options; end

  # source://rack-protection/3.0.5/lib/rack/protection/frame_options.rb#24
  def frame_options; end
end

class Rack::Protection::HttpOrigin < ::Rack::Protection::Base
  # source://rack-protection/3.0.5/lib/rack/protection/http_origin.rb#32
  def accepts?(env); end

  # source://rack-protection/3.0.5/lib/rack/protection/http_origin.rb#26
  def base_url(env); end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#24
  def default_options; end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#75
  def default_reaction(env); end
end

# source://rack-protection/3.0.5/lib/rack/protection/http_origin.rb#22
Rack::Protection::HttpOrigin::DEFAULT_PORTS = T.let(T.unsafe(nil), Hash)

class Rack::Protection::IPSpoofing < ::Rack::Protection::Base
  # source://rack-protection/3.0.5/lib/rack/protection/ip_spoofing.rb#16
  def accepts?(env); end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#75
  def default_reaction(env); end
end

class Rack::Protection::JsonCsrf < ::Rack::Protection::Base
  # source://rack-protection/3.0.5/lib/rack/protection/json_csrf.rb#26
  def call(env); end

  # source://rack-protection/3.0.5/lib/rack/protection/json_csrf.rb#55
  def close_body(body); end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#24
  def default_options; end

  # source://rack-protection/3.0.5/lib/rack/protection/json_csrf.rb#39
  def has_vector?(request, headers); end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#75
  def react(env); end

  # source://rack-protection/3.0.5/lib/rack/protection/json_csrf.rb#47
  def react_and_close(env, body); end
end

class Rack::Protection::PathTraversal < ::Rack::Protection::Base
  # source://rack-protection/3.0.5/lib/rack/protection/path_traversal.rb#15
  def call(env); end

  # source://rack-protection/3.0.5/lib/rack/protection/path_traversal.rb#23
  def cleanup(path); end
end

class Rack::Protection::ReferrerPolicy < ::Rack::Protection::Base
  # source://rack-protection/3.0.5/lib/rack/protection/referrer_policy.rb#20
  def call(env); end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#24
  def default_options; end
end

class Rack::Protection::RemoteReferrer < ::Rack::Protection::Base
  # source://rack-protection/3.0.5/lib/rack/protection/remote_referrer.rb#17
  def accepts?(env); end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#75
  def default_reaction(env); end
end

class Rack::Protection::RemoteToken < ::Rack::Protection::AuthenticityToken
  # source://rack-protection/3.0.5/lib/rack/protection/remote_token.rb#19
  def accepts?(env); end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#75
  def default_reaction(env); end
end

class Rack::Protection::SessionHijacking < ::Rack::Protection::Base
  # source://rack-protection/3.0.5/lib/rack/protection/session_hijacking.rb#21
  def accepts?(env); end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#24
  def default_options; end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#95
  def default_reaction(env); end

  # source://rack-protection/3.0.5/lib/rack/protection/session_hijacking.rb#32
  def encode(value); end
end

class Rack::Protection::StrictTransport < ::Rack::Protection::Base
  # source://rack-protection/3.0.5/lib/rack/protection/strict_transport.rb#34
  def call(env); end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#24
  def default_options; end

  # source://rack-protection/3.0.5/lib/rack/protection/strict_transport.rb#25
  def strict_transport; end
end

# source://rack-protection/3.0.5/lib/rack/protection/version.rb#5
Rack::Protection::VERSION = T.let(T.unsafe(nil), String)

class Rack::Protection::XSSHeader < ::Rack::Protection::Base
  # source://rack-protection/3.0.5/lib/rack/protection/xss_header.rb#19
  def call(env); end

  # source://rack-protection/3.0.5/lib/rack/protection/base.rb#24
  def default_options; end
end

# source://rack/2.2.5/lib/rack.rb#25
Rack::QUERY_STRING = T.let(T.unsafe(nil), String)

class Rack::QueryParser
  # source://rack/2.2.5/lib/rack/query_parser.rb#29
  def initialize(params_class, key_space_limit, param_depth_limit); end

  # source://rack/2.2.5/lib/rack/query_parser.rb#27
  def key_space_limit; end

  # source://rack/2.2.5/lib/rack/query_parser.rb#128
  def make_params; end

  # source://rack/2.2.5/lib/rack/query_parser.rb#136
  def new_depth_limit(param_depth_limit); end

  # source://rack/2.2.5/lib/rack/query_parser.rb#132
  def new_space_limit(key_space_limit); end

  # source://rack/2.2.5/lib/rack/query_parser.rb#87
  def normalize_params(params, name, v, depth); end

  # source://rack/2.2.5/lib/rack/query_parser.rb#27
  def param_depth_limit; end

  # source://rack/2.2.5/lib/rack/query_parser.rb#68
  def parse_nested_query(qs, d = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/query_parser.rb#40
  def parse_query(qs, d = T.unsafe(nil), &unescaper); end

  private

  # source://rack/2.2.5/lib/rack/query_parser.rb#146
  def params_hash_has_key?(hash, key); end

  # source://rack/2.2.5/lib/rack/query_parser.rb#142
  def params_hash_type?(obj); end

  # source://rack/2.2.5/lib/rack/query_parser.rb#158
  def unescape(s); end

  class << self
    # source://rack/2.2.5/lib/rack/query_parser.rb#23
    def make_default(key_space_limit, param_depth_limit); end
  end
end

# source://rack/2.2.5/lib/rack/query_parser.rb#8
Rack::QueryParser::COMMON_SEP = T.let(T.unsafe(nil), Hash)

# source://rack/2.2.5/lib/rack/query_parser.rb#7
Rack::QueryParser::DEFAULT_SEP = T.let(T.unsafe(nil), Regexp)

class Rack::QueryParser::InvalidParameterError < ::ArgumentError; end
class Rack::QueryParser::ParameterTypeError < ::TypeError; end

class Rack::QueryParser::Params
  # source://rack/2.2.5/lib/rack/query_parser.rb#163
  def initialize(limit); end

  # source://rack/2.2.5/lib/rack/query_parser.rb#169
  def [](key); end

  # source://rack/2.2.5/lib/rack/query_parser.rb#173
  def []=(key, value); end

  # source://rack/2.2.5/lib/rack/query_parser.rb#179
  def key?(key); end

  # source://rack/2.2.5/lib/rack/query_parser.rb#201
  def to_h; end

  # source://rack/2.2.5/lib/rack/query_parser.rb#201
  def to_params_hash; end
end

class Rack::QueryParser::ParamsTooDeepError < ::RangeError; end

# source://rack/2.2.5/lib/rack.rb#53
Rack::RACK_ERRORS = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#63
Rack::RACK_HIJACK = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#65
Rack::RACK_HIJACK_IO = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#55
Rack::RACK_INPUT = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#64
Rack::RACK_IS_HIJACK = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#54
Rack::RACK_LOGGER = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#76
Rack::RACK_METHODOVERRIDE_ORIGINAL_METHOD = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#67
Rack::RACK_MULTIPART_BUFFER_SIZE = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#68
Rack::RACK_MULTIPART_TEMPFILE_FACTORY = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#60
Rack::RACK_MULTIPROCESS = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#59
Rack::RACK_MULTITHREAD = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#66
Rack::RACK_RECURSIVE_INCLUDE = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#72
Rack::RACK_REQUEST_COOKIE_HASH = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#73
Rack::RACK_REQUEST_COOKIE_STRING = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#70
Rack::RACK_REQUEST_FORM_HASH = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#69
Rack::RACK_REQUEST_FORM_INPUT = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#71
Rack::RACK_REQUEST_FORM_VARS = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#74
Rack::RACK_REQUEST_QUERY_HASH = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#75
Rack::RACK_REQUEST_QUERY_STRING = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#61
Rack::RACK_RUNONCE = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#56
Rack::RACK_SESSION = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#57
Rack::RACK_SESSION_OPTIONS = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#77
Rack::RACK_SESSION_UNPACKED_COOKIE_DATA = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#58
Rack::RACK_SHOWSTATUS_DETAIL = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#52
Rack::RACK_TEMPFILES = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#62
Rack::RACK_URL_SCHEME = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#51
Rack::RACK_VERSION = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack/version.rb#23
Rack::RELEASE = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#22
Rack::REQUEST_METHOD = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#23
Rack::REQUEST_PATH = T.let(T.unsafe(nil), String)

class Rack::Recursive
  # source://rack/2.2.5/lib/rack/recursive.rb#35
  def initialize(app); end

  # source://rack/2.2.5/lib/rack/recursive.rb#43
  def _call(env); end

  # source://rack/2.2.5/lib/rack/recursive.rb#39
  def call(env); end

  # source://rack/2.2.5/lib/rack/recursive.rb#50
  def include(env, path); end
end

class Rack::Reloader
  # source://rack/2.2.5/lib/rack/reloader.rb#27
  def initialize(app, cooldown = T.unsafe(nil), backend = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/reloader.rb#38
  def call(env); end

  # source://rack/2.2.5/lib/rack/reloader.rb#52
  def reload!(stderr = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/reloader.rb#60
  def safe_load(file, mtime, stderr = T.unsafe(nil)); end
end

module Rack::Reloader::Stat
  # source://rack/2.2.5/lib/rack/reloader.rb#90
  def figure_path(file, paths); end

  # source://rack/2.2.5/lib/rack/reloader.rb#71
  def rotation; end

  # source://rack/2.2.5/lib/rack/reloader.rb#105
  def safe_stat(file); end
end

class Rack::Request
  include ::Rack::Request::Env
  include ::Rack::Request::Helpers

  # source://rack/2.2.5/lib/rack/request.rb#26
  def initialize(env); end

  # source://rack/2.2.5/lib/rack/request.rb#40
  def delete_param(k); end

  # source://rack/2.2.5/lib/rack/request.rb#31
  def params; end

  # source://rack/2.2.5/lib/rack/request.rb#31
  def query; end

  # source://rack/2.2.5/lib/rack/request.rb#35
  def update_param(k, v); end

  # source://yard/0.9.28/lib/yard/server/rack_adapter.rb#86
  def version_supplied; end

  # source://yard/0.9.28/lib/yard/server/rack_adapter.rb#86
  def version_supplied=(_arg0); end

  # source://yard/0.9.28/lib/yard/server/rack_adapter.rb#88
  def xhr?; end

  class << self
    # source://rack/2.2.5/lib/rack/request.rb#16
    def ip_filter; end

    # source://rack/2.2.5/lib/rack/request.rb#16
    def ip_filter=(_arg0); end
  end
end

# source://rack/2.2.5/lib/rack/request.rb#20
Rack::Request::ALLOWED_SCHEMES = T.let(T.unsafe(nil), Array)

module Rack::Request::Env
  # source://rack/2.2.5/lib/rack/request.rb#50
  def initialize(env); end

  # source://rack/2.2.5/lib/rack/request.rb#91
  def add_header(key, v); end

  # source://rack/2.2.5/lib/rack/request.rb#102
  def delete_header(name); end

  # source://rack/2.2.5/lib/rack/request.rb#73
  def each_header(&block); end

  # source://rack/2.2.5/lib/rack/request.rb#48
  def env; end

  # source://rack/2.2.5/lib/rack/request.rb#68
  def fetch_header(name, &block); end

  # source://rack/2.2.5/lib/rack/request.rb#62
  def get_header(name); end

  # source://rack/2.2.5/lib/rack/request.rb#57
  def has_header?(name); end

  # source://rack/2.2.5/lib/rack/request.rb#78
  def set_header(name, v); end

  private

  # source://rack/2.2.5/lib/rack/request.rb#106
  def initialize_copy(other); end
end

module Rack::Request::Helpers
  # source://rack/2.2.5/lib/rack/request.rb#426
  def GET; end

  # source://rack/2.2.5/lib/rack/request.rb#440
  def POST; end

  # source://rack/2.2.5/lib/rack/request.rb#532
  def [](key); end

  # source://rack/2.2.5/lib/rack/request.rb#543
  def []=(key, value); end

  # source://rack/2.2.5/lib/rack/request.rb#519
  def accept_encoding; end

  # source://rack/2.2.5/lib/rack/request.rb#523
  def accept_language; end

  # source://rack/2.2.5/lib/rack/request.rb#227
  def authority; end

  # source://rack/2.2.5/lib/rack/request.rb#502
  def base_url; end

  # source://rack/2.2.5/lib/rack/request.rb#150
  def body; end

  # source://rack/2.2.5/lib/rack/request.rb#400
  def content_charset; end

  # source://rack/2.2.5/lib/rack/request.rb#159
  def content_length; end

  # source://rack/2.2.5/lib/rack/request.rb#271
  def content_type; end

  # source://rack/2.2.5/lib/rack/request.rb#256
  def cookies; end

  # source://rack/2.2.5/lib/rack/request.rb#181
  def delete?; end

  # source://rack/2.2.5/lib/rack/request.rb#497
  def delete_param(k); end

  # source://rack/2.2.5/lib/rack/request.rb#412
  def form_data?; end

  # source://rack/2.2.5/lib/rack/request.rb#344
  def forwarded_authority; end

  # source://rack/2.2.5/lib/rack/request.rb#330
  def forwarded_for; end

  # source://rack/2.2.5/lib/rack/request.rb#338
  def forwarded_port; end

  # source://rack/2.2.5/lib/rack/request.rb#515
  def fullpath; end

  # source://rack/2.2.5/lib/rack/request.rb#184
  def get?; end

  # source://rack/2.2.5/lib/rack/request.rb#187
  def head?; end

  # source://rack/2.2.5/lib/rack/request.rb#296
  def host; end

  # source://rack/2.2.5/lib/rack/request.rb#281
  def host_authority; end

  # source://rack/2.2.5/lib/rack/request.rb#285
  def host_with_port(authority = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/request.rb#304
  def hostname; end

  # source://rack/2.2.5/lib/rack/request.rb#354
  def ip; end

  # source://rack/2.2.5/lib/rack/request.rb#193
  def link?; end

  # source://rack/2.2.5/lib/rack/request.rb#160
  def logger; end

  # source://rack/2.2.5/lib/rack/request.rb#383
  def media_type; end

  # source://rack/2.2.5/lib/rack/request.rb#392
  def media_type_params; end

  # source://rack/2.2.5/lib/rack/request.rb#162
  def multithread?; end

  # source://rack/2.2.5/lib/rack/request.rb#190
  def options?; end

  # source://rack/2.2.5/lib/rack/request.rb#468
  def params; end

  # source://rack/2.2.5/lib/rack/request.rb#421
  def parseable_data?; end

  # source://rack/2.2.5/lib/rack/request.rb#196
  def patch?; end

  # source://rack/2.2.5/lib/rack/request.rb#511
  def path; end

  # source://rack/2.2.5/lib/rack/request.rb#154
  def path_info; end

  # source://rack/2.2.5/lib/rack/request.rb#155
  def path_info=(s); end

  # source://rack/2.2.5/lib/rack/request.rb#308
  def port; end

  # source://rack/2.2.5/lib/rack/request.rb#199
  def post?; end

  # source://rack/2.2.5/lib/rack/request.rb#202
  def put?; end

  # source://rack/2.2.5/lib/rack/request.rb#158
  def query_string; end

  # source://rack/2.2.5/lib/rack/request.rb#165
  def referer; end

  # source://rack/2.2.5/lib/rack/request.rb#165
  def referrer; end

  # source://rack/2.2.5/lib/rack/request.rb#157
  def request_method; end

  # source://rack/2.2.5/lib/rack/request.rb#210
  def scheme; end

  # source://rack/2.2.5/lib/rack/request.rb#151
  def script_name; end

  # source://rack/2.2.5/lib/rack/request.rb#152
  def script_name=(s); end

  # source://rack/2.2.5/lib/rack/request.rb#233
  def server_authority; end

  # source://rack/2.2.5/lib/rack/request.rb#246
  def server_name; end

  # source://rack/2.2.5/lib/rack/request.rb#250
  def server_port; end

  # source://rack/2.2.5/lib/rack/request.rb#168
  def session; end

  # source://rack/2.2.5/lib/rack/request.rb#174
  def session_options; end

  # source://rack/2.2.5/lib/rack/request.rb#350
  def ssl?; end

  # source://rack/2.2.5/lib/rack/request.rb#205
  def trace?; end

  # source://rack/2.2.5/lib/rack/request.rb#527
  def trusted_proxy?(ip); end

  # source://rack/2.2.5/lib/rack/request.rb#208
  def unlink?; end

  # source://rack/2.2.5/lib/rack/request.rb#477
  def update_param(k, v); end

  # source://rack/2.2.5/lib/rack/request.rb#507
  def url; end

  # source://rack/2.2.5/lib/rack/request.rb#161
  def user_agent; end

  # source://rack/2.2.5/lib/rack/request.rb#552
  def values_at(*keys); end

  # source://rack/2.2.5/lib/rack/request.rb#276
  def xhr?; end

  private

  # source://rack/2.2.5/lib/rack/request.rb#641
  def allowed_scheme(header); end

  # source://rack/2.2.5/lib/rack/request.rb#558
  def default_session; end

  # source://rack/2.2.5/lib/rack/request.rb#645
  def extract_proto_header(header); end

  # source://rack/2.2.5/lib/rack/request.rb#636
  def forwarded_scheme; end

  # source://rack/2.2.5/lib/rack/request.rb#574
  def parse_http_accept_header(header); end

  # source://rack/2.2.5/lib/rack/request.rb#593
  def parse_multipart; end

  # source://rack/2.2.5/lib/rack/request.rb#589
  def parse_query(qs, d = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/request.rb#585
  def query_parser; end

  # source://rack/2.2.5/lib/rack/request.rb#632
  def reject_trusted_ip_addresses(ip_addresses); end

  # source://rack/2.2.5/lib/rack/request.rb#619
  def split_authority(authority); end

  # source://rack/2.2.5/lib/rack/request.rb#597
  def split_header(value); end

  # source://rack/2.2.5/lib/rack/request.rb#561
  def wrap_ipv6(host); end
end

# source://rack/2.2.5/lib/rack/request.rb#130
Rack::Request::Helpers::DEFAULT_PORTS = T.let(T.unsafe(nil), Hash)

# source://rack/2.2.5/lib/rack/request.rb#115
Rack::Request::Helpers::FORM_DATA_MEDIA_TYPES = T.let(T.unsafe(nil), Array)

# source://rack/2.2.5/lib/rack/request.rb#133
Rack::Request::Helpers::HTTP_X_FORWARDED_FOR = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack/request.rb#136
Rack::Request::Helpers::HTTP_X_FORWARDED_HOST = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack/request.rb#145
Rack::Request::Helpers::HTTP_X_FORWARDED_PORT = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack/request.rb#142
Rack::Request::Helpers::HTTP_X_FORWARDED_PROTO = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack/request.rb#139
Rack::Request::Helpers::HTTP_X_FORWARDED_SCHEME = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack/request.rb#148
Rack::Request::Helpers::HTTP_X_FORWARDED_SSL = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack/request.rb#123
Rack::Request::Helpers::PARSEABLE_DATA_MEDIA_TYPES = T.let(T.unsafe(nil), Array)

# source://rack/2.2.5/lib/rack/request.rb#21
Rack::Request::SCHEME_WHITELIST = T.let(T.unsafe(nil), Array)

class Rack::Response
  include ::Rack::Response::Helpers

  # source://rack/2.2.5/lib/rack/response.rb#42
  def initialize(body = T.unsafe(nil), status = T.unsafe(nil), headers = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/response.rb#127
  def [](key); end

  # source://rack/2.2.5/lib/rack/response.rb#128
  def []=(key, v); end

  # source://rack/2.2.5/lib/rack/response.rb#26
  def body; end

  # source://rack/2.2.5/lib/rack/response.rb#26
  def body=(_arg0); end

  # source://rack/2.2.5/lib/rack/response.rb#73
  def chunked?; end

  # source://rack/2.2.5/lib/rack/response.rb#118
  def close; end

  # source://rack/2.2.5/lib/rack/response.rb#129
  def delete_header(key); end

  # source://rack/2.2.5/lib/rack/response.rb#98
  def each(&callback); end

  # source://rack/2.2.5/lib/rack/response.rb#122
  def empty?; end

  # source://rack/2.2.5/lib/rack/response.rb#80
  def finish(&block); end

  # source://rack/2.2.5/lib/rack/response.rb#127
  def get_header(key); end

  # source://rack/2.2.5/lib/rack/response.rb#126
  def has_header?(key); end

  # source://rack/2.2.5/lib/rack/response.rb#27
  def header; end

  # source://rack/2.2.5/lib/rack/response.rb#27
  def headers; end

  # source://rack/2.2.5/lib/rack/response.rb#26
  def length; end

  # source://rack/2.2.5/lib/rack/response.rb#26
  def length=(_arg0); end

  # source://rack/2.2.5/lib/rack/response.rb#68
  def redirect(target, status = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/response.rb#128
  def set_header(key, v); end

  # source://rack/2.2.5/lib/rack/response.rb#26
  def status; end

  # source://rack/2.2.5/lib/rack/response.rb#26
  def status=(_arg0); end

  # source://rack/2.2.5/lib/rack/response.rb#80
  def to_a(&block); end

  # source://rack/2.2.5/lib/rack/response.rb#112
  def write(chunk); end

  class << self
    # source://rack/2.2.5/lib/rack/response.rb#19
    def [](status, headers, body); end
  end
end

# source://rack/2.2.5/lib/rack/response.rb#23
Rack::Response::CHUNKED = T.let(T.unsafe(nil), String)

module Rack::Response::Helpers
  # source://rack/2.2.5/lib/rack/response.rb#145
  def accepted?; end

  # source://rack/2.2.5/lib/rack/response.rb#171
  def add_header(key, v); end

  # source://rack/2.2.5/lib/rack/response.rb#148
  def bad_request?; end

  # source://rack/2.2.5/lib/rack/response.rb#246
  def cache!(duration = T.unsafe(nil), directive: T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/response.rb#229
  def cache_control; end

  # source://rack/2.2.5/lib/rack/response.rb#233
  def cache_control=(v); end

  # source://rack/2.2.5/lib/rack/response.rb#140
  def client_error?; end

  # source://rack/2.2.5/lib/rack/response.rb#199
  def content_length; end

  # source://rack/2.2.5/lib/rack/response.rb#182
  def content_type; end

  # source://rack/2.2.5/lib/rack/response.rb#187
  def content_type=(content_type); end

  # source://rack/2.2.5/lib/rack/response.rb#144
  def created?; end

  # source://rack/2.2.5/lib/rack/response.rb#217
  def delete_cookie(key, value = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/response.rb#238
  def do_not_cache!; end

  # source://rack/2.2.5/lib/rack/response.rb#253
  def etag; end

  # source://rack/2.2.5/lib/rack/response.rb#257
  def etag=(v); end

  # source://rack/2.2.5/lib/rack/response.rb#150
  def forbidden?; end

  # source://rack/2.2.5/lib/rack/response.rb#158
  def include?(header); end

  # source://rack/2.2.5/lib/rack/response.rb#137
  def informational?; end

  # source://rack/2.2.5/lib/rack/response.rb#135
  def invalid?; end

  # source://rack/2.2.5/lib/rack/response.rb#204
  def location; end

  # source://rack/2.2.5/lib/rack/response.rb#208
  def location=(location); end

  # source://rack/2.2.5/lib/rack/response.rb#191
  def media_type; end

  # source://rack/2.2.5/lib/rack/response.rb#195
  def media_type_params; end

  # source://rack/2.2.5/lib/rack/response.rb#152
  def method_not_allowed?; end

  # source://rack/2.2.5/lib/rack/response.rb#147
  def moved_permanently?; end

  # source://rack/2.2.5/lib/rack/response.rb#146
  def no_content?; end

  # source://rack/2.2.5/lib/rack/response.rb#151
  def not_found?; end

  # source://rack/2.2.5/lib/rack/response.rb#143
  def ok?; end

  # source://rack/2.2.5/lib/rack/response.rb#153
  def precondition_failed?; end

  # source://rack/2.2.5/lib/rack/response.rb#156
  def redirect?; end

  # source://rack/2.2.5/lib/rack/response.rb#139
  def redirection?; end

  # source://rack/2.2.5/lib/rack/response.rb#141
  def server_error?; end

  # source://rack/2.2.5/lib/rack/response.rb#212
  def set_cookie(key, value); end

  # source://rack/2.2.5/lib/rack/response.rb#221
  def set_cookie_header; end

  # source://rack/2.2.5/lib/rack/response.rb#225
  def set_cookie_header=(v); end

  # source://rack/2.2.5/lib/rack/response.rb#138
  def successful?; end

  # source://rack/2.2.5/lib/rack/response.rb#149
  def unauthorized?; end

  # source://rack/2.2.5/lib/rack/response.rb#154
  def unprocessable?; end

  protected

  # source://rack/2.2.5/lib/rack/response.rb#287
  def append(chunk); end

  # source://rack/2.2.5/lib/rack/response.rb#263
  def buffered_body!; end
end

class Rack::Response::Raw
  include ::Rack::Response::Helpers

  # source://rack/2.2.5/lib/rack/response.rb#307
  def initialize(status, headers); end

  # source://rack/2.2.5/lib/rack/response.rb#315
  def delete_header(key); end

  # source://rack/2.2.5/lib/rack/response.rb#313
  def get_header(key); end

  # source://rack/2.2.5/lib/rack/response.rb#312
  def has_header?(key); end

  # source://rack/2.2.5/lib/rack/response.rb#304
  def headers; end

  # source://rack/2.2.5/lib/rack/response.rb#314
  def set_header(key, v); end

  # source://rack/2.2.5/lib/rack/response.rb#305
  def status; end

  # source://rack/2.2.5/lib/rack/response.rb#305
  def status=(_arg0); end
end

# source://rack/2.2.5/lib/rack/response.rb#24
Rack::Response::STATUS_WITH_NO_ENTITY_BODY = T.let(T.unsafe(nil), Hash)

class Rack::RewindableInput
  # source://rack/2.2.5/lib/rack/rewindable_input.rb#17
  def initialize(io); end

  # source://rack/2.2.5/lib/rack/rewindable_input.rb#48
  def close; end

  # source://rack/2.2.5/lib/rack/rewindable_input.rb#33
  def each(&block); end

  # source://rack/2.2.5/lib/rack/rewindable_input.rb#23
  def gets; end

  # source://rack/2.2.5/lib/rack/rewindable_input.rb#28
  def read(*args); end

  # source://rack/2.2.5/lib/rack/rewindable_input.rb#38
  def rewind; end

  private

  # source://rack/2.2.5/lib/rack/rewindable_input.rb#90
  def filesystem_has_posix_semantics?; end

  # source://rack/2.2.5/lib/rack/rewindable_input.rb#61
  def make_rewindable; end
end

class Rack::Runtime
  # source://rack/2.2.5/lib/rack/runtime.rb#14
  def initialize(app, name = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/runtime.rb#20
  def call(env); end
end

# source://rack/2.2.5/lib/rack/runtime.rb#11
Rack::Runtime::FORMAT_STRING = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack/runtime.rb#12
Rack::Runtime::HEADER_NAME = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#24
Rack::SCRIPT_NAME = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#27
Rack::SERVER_NAME = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#28
Rack::SERVER_PORT = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#26
Rack::SERVER_PROTOCOL = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#33
Rack::SET_COOKIE = T.let(T.unsafe(nil), String)

class Rack::Sendfile
  # source://rack/2.2.5/lib/rack/sendfile.rb#101
  def initialize(app, variation = T.unsafe(nil), mappings = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/sendfile.rb#109
  def call(env); end

  private

  # source://rack/2.2.5/lib/rack/sendfile.rb#149
  def map_accel_path(env, path); end

  # source://rack/2.2.5/lib/rack/sendfile.rb#143
  def variation(env); end
end

class Rack::Server
  # source://rack/2.2.5/lib/rack/server.rb#215
  def initialize(options = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/server.rb#248
  def app; end

  # source://rack/2.2.5/lib/rack/server.rb#234
  def default_options; end

  # source://rack/2.2.5/lib/rack/server.rb#282
  def middleware; end

  # source://rack/2.2.5/lib/rack/server.rb#229
  def options; end

  # source://rack/2.2.5/lib/rack/server.rb#171
  def options=(_arg0); end

  # source://rack/2.2.5/lib/rack/server.rb#330
  def server; end

  # source://rack/2.2.5/lib/rack/server.rb#286
  def start(&block); end

  private

  # source://rack/2.2.5/lib/rack/server.rb#411
  def build_app(app); end

  # source://rack/2.2.5/lib/rack/server.rb#344
  def build_app_and_options_from_config; end

  # source://rack/2.2.5/lib/rack/server.rb#392
  def build_app_from_string; end

  # source://rack/2.2.5/lib/rack/server.rb#440
  def check_pid!; end

  # source://rack/2.2.5/lib/rack/server.rb#425
  def daemonize_app; end

  # source://rack/2.2.5/lib/rack/server.rb#354
  def handle_profiling(heapfile, profile_mode, filename); end

  # source://rack/2.2.5/lib/rack/server.rb#382
  def make_profile_name(filename); end

  # source://rack/2.2.5/lib/rack/server.rb#407
  def opt_parser; end

  # source://rack/2.2.5/lib/rack/server.rb#396
  def parse_options(args); end

  # source://rack/2.2.5/lib/rack/server.rb#450
  def pidfile_process_status; end

  # source://rack/2.2.5/lib/rack/server.rb#421
  def wrapped_app; end

  # source://rack/2.2.5/lib/rack/server.rb#432
  def write_pid; end

  class << self
    # source://rack/2.2.5/lib/rack/server.rb#259
    def default_middleware_by_environment; end

    # source://rack/2.2.5/lib/rack/server.rb#253
    def logging_middleware; end

    # source://rack/2.2.5/lib/rack/server.rb#277
    def middleware; end

    # source://rack/2.2.5/lib/rack/server.rb#167
    def start(options = T.unsafe(nil)); end
  end
end

class Rack::Server::Options
  # source://rack/2.2.5/lib/rack/server.rb#127
  def handler_opts(options); end

  # source://rack/2.2.5/lib/rack/server.rb#12
  def parse!(args); end
end

module Rack::Session; end
module Rack::Session::Abstract; end

class Rack::Session::Abstract::ID < ::Rack::Session::Abstract::Persisted
  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#517
  def delete_session(req, sid, options); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#502
  def find_session(req, sid); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#510
  def write_session(req, sid, session, options); end

  class << self
    # source://rack/2.2.5/lib/rack/session/abstract/id.rb#488
    def inherited(klass); end
  end
end

class Rack::Session::Abstract::Persisted
  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#250
  def initialize(app, options = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#259
  def call(env); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#373
  def commit_session(req, res); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#263
  def context(env, app = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#248
  def default_options; end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#248
  def key; end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#248
  def sid_secure; end

  private

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#342
  def commit_session?(req, session, options); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#408
  def cookie_value(data); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#328
  def current_session_id(req); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#448
  def delete_session(req, sid, options); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#320
  def extract_session_id(request); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#433
  def find_session(env, sid); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#359
  def force_options?(options); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#355
  def forced_session_update?(session, options); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#288
  def generate_sid(secure = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#278
  def initialize_sid; end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#312
  def load_session(req); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#351
  def loaded_session?(session); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#274
  def make_request(env); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#301
  def prepare_session(req); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#363
  def security_matches?(request, options); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#424
  def session_class; end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#334
  def session_exists?(req); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#415
  def set_cookie(request, res, cookie); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#441
  def write_session(req, sid, session, options); end
end

# source://rack/2.2.5/lib/rack/session/abstract/id.rb#234
Rack::Session::Abstract::Persisted::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

class Rack::Session::Abstract::PersistedSecure < ::Rack::Session::Abstract::Persisted
  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#471
  def extract_session_id(*_arg0); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#465
  def generate_sid(*_arg0); end

  private

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#482
  def cookie_value(data); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#478
  def session_class; end
end

class Rack::Session::Abstract::PersistedSecure::SecureSessionHash < ::Rack::Session::Abstract::SessionHash
  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#455
  def [](key); end
end

class Rack::Session::Abstract::SessionHash
  include ::Enumerable

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#62
  def initialize(store, req); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#82
  def [](key); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#108
  def []=(key, value); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#114
  def clear; end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#140
  def delete(key); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#119
  def destroy; end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#87
  def dig(key, *keys); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#77
  def each(&block); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#163
  def empty?; end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#153
  def exists?; end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#92
  def fetch(key, default = T.unsafe(nil), &block); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#101
  def has_key?(key); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#68
  def id; end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#46
  def id=(_arg0); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#101
  def include?(key); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#145
  def inspect; end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#101
  def key?(key); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#168
  def keys; end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#159
  def loaded?; end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#129
  def merge!(hash); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#73
  def options; end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#135
  def replace(hash); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#108
  def store(key, value); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#124
  def to_hash; end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#129
  def update(hash); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#173
  def values; end

  private

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#188
  def load!; end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#180
  def load_for_read!; end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#184
  def load_for_write!; end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#194
  def stringify_keys(other); end

  class << self
    # source://rack/2.2.5/lib/rack/session/abstract/id.rb#50
    def find(req); end

    # source://rack/2.2.5/lib/rack/session/abstract/id.rb#54
    def set(req, session); end

    # source://rack/2.2.5/lib/rack/session/abstract/id.rb#58
    def set_options(req, options); end
  end
end

# source://rack/2.2.5/lib/rack/session/abstract/id.rb#48
Rack::Session::Abstract::SessionHash::Unspecified = T.let(T.unsafe(nil), Object)

class Rack::Session::Cookie < ::Rack::Session::Abstract::PersistedSecure
  # source://rack/2.2.5/lib/rack/session/cookie.rb#107
  def initialize(app, options = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/session/cookie.rb#105
  def coder; end

  private

  # source://rack/2.2.5/lib/rack/session/cookie.rb#180
  def delete_session(req, session_id, options); end

  # source://rack/2.2.5/lib/rack/session/cookie.rb#185
  def digest_match?(data, digest); end

  # source://rack/2.2.5/lib/rack/session/cookie.rb#132
  def extract_session_id(request); end

  # source://rack/2.2.5/lib/rack/session/cookie.rb#126
  def find_session(req, sid); end

  # source://rack/2.2.5/lib/rack/session/cookie.rb#192
  def generate_hmac(data, secret); end

  # source://rack/2.2.5/lib/rack/session/cookie.rb#149
  def persistent_session_id!(data, sid = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/session/cookie.rb#196
  def secure?(options); end

  # source://rack/2.2.5/lib/rack/session/cookie.rb#136
  def unpacked_cookie_data(request); end

  # source://rack/2.2.5/lib/rack/session/cookie.rb#164
  def write_session(req, session_id, session, options); end
end

class Rack::Session::Cookie::Base64
  # source://rack/2.2.5/lib/rack/session/cookie.rb#56
  def decode(str); end

  # source://rack/2.2.5/lib/rack/session/cookie.rb#52
  def encode(str); end
end

class Rack::Session::Cookie::Base64::JSON < ::Rack::Session::Cookie::Base64
  # source://rack/2.2.5/lib/rack/session/cookie.rb#79
  def decode(str); end

  # source://rack/2.2.5/lib/rack/session/cookie.rb#75
  def encode(obj); end
end

class Rack::Session::Cookie::Base64::Marshal < ::Rack::Session::Cookie::Base64
  # source://rack/2.2.5/lib/rack/session/cookie.rb#66
  def decode(str); end

  # source://rack/2.2.5/lib/rack/session/cookie.rb#62
  def encode(str); end
end

class Rack::Session::Cookie::Base64::ZipJSON < ::Rack::Session::Cookie::Base64
  # source://rack/2.2.5/lib/rack/session/cookie.rb#90
  def decode(str); end

  # source://rack/2.2.5/lib/rack/session/cookie.rb#86
  def encode(obj); end
end

class Rack::Session::Cookie::Identity
  # source://rack/2.2.5/lib/rack/session/cookie.rb#102
  def decode(str); end

  # source://rack/2.2.5/lib/rack/session/cookie.rb#101
  def encode(str); end
end

class Rack::Session::Cookie::SessionId
  # source://rack/2.2.5/lib/rack/session/cookie.rb#158
  def initialize(session_id, cookie_value); end

  # source://rack/2.2.5/lib/rack/session/cookie.rb#156
  def cookie_value; end
end

class Rack::Session::Pool < ::Rack::Session::Abstract::PersistedSecure
  # source://rack/2.2.5/lib/rack/session/pool.rb#33
  def initialize(app, options = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/session/pool.rb#63
  def delete_session(req, session_id, options); end

  # source://rack/2.2.5/lib/rack/session/pool.rb#46
  def find_session(req, sid); end

  # source://rack/2.2.5/lib/rack/session/pool.rb#39
  def generate_sid; end

  # source://rack/2.2.5/lib/rack/session/pool.rb#30
  def mutex; end

  # source://rack/2.2.5/lib/rack/session/pool.rb#30
  def pool; end

  # source://rack/2.2.5/lib/rack/session/pool.rb#71
  def with_lock(req); end

  # source://rack/2.2.5/lib/rack/session/pool.rb#56
  def write_session(req, session_id, new_session, options); end

  private

  # source://rack/2.2.5/lib/rack/session/pool.rb#80
  def get_session_with_fallback(sid); end
end

# source://rack/2.2.5/lib/rack/session/pool.rb#31
Rack::Session::Pool::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

class Rack::Session::SessionId
  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#20
  def initialize(public_id); end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#18
  def cookie_value; end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#31
  def empty?; end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#32
  def inspect; end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#24
  def private_id; end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#18
  def public_id; end

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#18
  def to_s; end

  private

  # source://rack/2.2.5/lib/rack/session/abstract/id.rb#36
  def hash_sid(sid); end
end

# source://rack/2.2.5/lib/rack/session/abstract/id.rb#16
Rack::Session::SessionId::ID_VERSION = T.let(T.unsafe(nil), Integer)

class Rack::ShowExceptions
  # source://rack/2.2.5/lib/rack/show_exceptions.rb#18
  def initialize(app); end

  # source://rack/2.2.5/lib/rack/show_exceptions.rb#22
  def call(env); end

  # source://rack/2.2.5/lib/rack/show_exceptions.rb#57
  def dump_exception(exception); end

  # source://rack/2.2.5/lib/rack/show_exceptions.rb#103
  def h(obj); end

  # source://rack/2.2.5/lib/rack/show_exceptions.rb#48
  def prefers_plaintext?(env); end

  # source://rack/2.2.5/lib/rack/show_exceptions.rb#63
  def pretty(env, exception); end

  # source://rack/2.2.5/lib/rack/show_exceptions.rb#99
  def template; end

  private

  # source://rack/2.2.5/lib/rack/show_exceptions.rb#52
  def accepts_html?(env); end
end

# source://rack/2.2.5/lib/rack/show_exceptions.rb#16
Rack::ShowExceptions::CONTEXT = T.let(T.unsafe(nil), Integer)

# source://rack/2.2.5/lib/rack/show_exceptions.rb#118
Rack::ShowExceptions::TEMPLATE = T.let(T.unsafe(nil), ERB)

class Rack::ShowStatus
  # source://rack/2.2.5/lib/rack/show_status.rb#14
  def initialize(app); end

  # source://rack/2.2.5/lib/rack/show_status.rb#19
  def call(env); end

  # source://rack/2.2.5/lib/rack/show_status.rb#44
  def h(obj); end
end

# source://rack/2.2.5/lib/rack/show_status.rb#59
Rack::ShowStatus::TEMPLATE = T.let(T.unsafe(nil), String)

class Rack::Static
  # source://rack/2.2.5/lib/rack/static.rb#91
  def initialize(app, options = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/static.rb#107
  def add_index_root?(path); end

  # source://rack/2.2.5/lib/rack/static.rb#166
  def applicable_rules(path); end

  # source://rack/2.2.5/lib/rack/static.rb#123
  def call(env); end

  # source://rack/2.2.5/lib/rack/static.rb#119
  def can_serve(path); end

  # source://rack/2.2.5/lib/rack/static.rb#111
  def overwrite_file_path(path); end

  # source://rack/2.2.5/lib/rack/static.rb#115
  def route_file(path); end
end

# source://rack/2.2.5/lib/rack.rb#48
Rack::TRACE = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack.rb#34
Rack::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)

class Rack::TempfileReaper
  # source://rack/2.2.5/lib/rack/tempfile_reaper.rb#9
  def initialize(app); end

  # source://rack/2.2.5/lib/rack/tempfile_reaper.rb#13
  def call(env); end
end

# source://rack/2.2.5/lib/rack.rb#47
Rack::UNLINK = T.let(T.unsafe(nil), String)

class Rack::URLMap
  # source://rack/2.2.5/lib/rack/urlmap.rb#19
  def initialize(map = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/urlmap.rb#46
  def call(env); end

  # source://rack/2.2.5/lib/rack/urlmap.rb#23
  def remap(map); end

  private

  # source://rack/2.2.5/lib/rack/urlmap.rb#85
  def casecmp?(v1, v2); end
end

module Rack::Utils
  private

  # source://rack/2.2.5/lib/rack/utils.rb#226
  def add_cookie_to_header(header, key, value); end

  # source://rack/2.2.5/lib/rack/utils.rb#309
  def add_remove_cookie_to_header(header, key, value = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/utils.rb#148
  def best_q_match(q_value_header, available_mimes); end

  # source://rack/2.2.5/lib/rack/utils.rb#115
  def build_nested_query(value, prefix = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/utils.rb#105
  def build_query(params); end

  # source://rack/2.2.5/lib/rack/utils.rb#341
  def byte_ranges(env, size); end

  # source://rack/2.2.5/lib/rack/utils.rb#594
  def clean_path_info(path_info); end

  # source://rack/2.2.5/lib/rack/utils.rb#86
  def clock_time; end

  # source://rack/2.2.5/lib/rack/utils.rb#302
  def delete_cookie_header!(header, key, value = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/utils.rb#38
  def escape(s); end

  # source://rack/2.2.5/lib/rack/utils.rb#173
  def escape_html(string); end

  # source://rack/2.2.5/lib/rack/utils.rb#44
  def escape_path(s); end

  # source://rack/2.2.5/lib/rack/utils.rb#346
  def get_byte_ranges(http_range, size); end

  # source://rack/2.2.5/lib/rack/utils.rb#272
  def make_delete_cookie_header(header, key, value); end

  # source://rack/2.2.5/lib/rack/utils.rb#209
  def parse_cookies(env); end

  # source://rack/2.2.5/lib/rack/utils.rb#213
  def parse_cookies_header(header); end

  # source://rack/2.2.5/lib/rack/utils.rb#101
  def parse_nested_query(qs, d = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/utils.rb#97
  def parse_query(qs, d = T.unsafe(nil), &unescaper); end

  # source://rack/2.2.5/lib/rack/utils.rb#133
  def q_values(q_value_header); end

  # source://rack/2.2.5/lib/rack/utils.rb#332
  def rfc2109(time); end

  # source://rack/2.2.5/lib/rack/utils.rb#319
  def rfc2822(time); end

  # source://rack/2.2.5/lib/rack/utils.rb#380
  def secure_compare(a, b); end

  # source://rack/2.2.5/lib/rack/utils.rb#177
  def select_best_encoding(available_encodings, accept_encoding); end

  # source://rack/2.2.5/lib/rack/utils.rb#267
  def set_cookie_header!(header, key, value); end

  # source://rack/2.2.5/lib/rack/utils.rb#584
  def status_code(status); end

  # source://rack/2.2.5/lib/rack/utils.rb#56
  def unescape(s, encoding = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/utils.rb#50
  def unescape_path(s); end

  # source://rack/2.2.5/lib/rack/utils.rb#611
  def valid_path?(path); end

  class << self
    # source://rack/2.2.5/lib/rack/utils.rb#226
    def add_cookie_to_header(header, key, value); end

    # source://rack/2.2.5/lib/rack/utils.rb#309
    def add_remove_cookie_to_header(header, key, value = T.unsafe(nil)); end

    # source://rack/2.2.5/lib/rack/utils.rb#148
    def best_q_match(q_value_header, available_mimes); end

    # source://rack/2.2.5/lib/rack/utils.rb#115
    def build_nested_query(value, prefix = T.unsafe(nil)); end

    # source://rack/2.2.5/lib/rack/utils.rb#105
    def build_query(params); end

    # source://rack/2.2.5/lib/rack/utils.rb#341
    def byte_ranges(env, size); end

    # source://rack/2.2.5/lib/rack/utils.rb#594
    def clean_path_info(path_info); end

    # source://rack/2.2.5/lib/rack/utils.rb#86
    def clock_time; end

    # source://rack/2.2.5/lib/rack/utils.rb#29
    def default_query_parser; end

    # source://rack/2.2.5/lib/rack/utils.rb#29
    def default_query_parser=(_arg0); end

    # source://rack/2.2.5/lib/rack/utils.rb#302
    def delete_cookie_header!(header, key, value = T.unsafe(nil)); end

    # source://rack/2.2.5/lib/rack/utils.rb#38
    def escape(s); end

    # source://rack/2.2.5/lib/rack/utils.rb#173
    def escape_html(string); end

    # source://rack/2.2.5/lib/rack/utils.rb#44
    def escape_path(s); end

    # source://rack/2.2.5/lib/rack/utils.rb#346
    def get_byte_ranges(http_range, size); end

    # source://rack/2.2.5/lib/rack/utils.rb#77
    def key_space_limit; end

    # source://rack/2.2.5/lib/rack/utils.rb#81
    def key_space_limit=(v); end

    # source://rack/2.2.5/lib/rack/utils.rb#272
    def make_delete_cookie_header(header, key, value); end

    # source://rack/2.2.5/lib/rack/utils.rb#61
    def multipart_part_limit; end

    # source://rack/2.2.5/lib/rack/utils.rb#61
    def multipart_part_limit=(_arg0); end

    # source://rack/2.2.5/lib/rack/utils.rb#69
    def param_depth_limit; end

    # source://rack/2.2.5/lib/rack/utils.rb#73
    def param_depth_limit=(v); end

    # source://rack/2.2.5/lib/rack/utils.rb#209
    def parse_cookies(env); end

    # source://rack/2.2.5/lib/rack/utils.rb#213
    def parse_cookies_header(header); end

    # source://rack/2.2.5/lib/rack/utils.rb#101
    def parse_nested_query(qs, d = T.unsafe(nil)); end

    # source://rack/2.2.5/lib/rack/utils.rb#97
    def parse_query(qs, d = T.unsafe(nil), &unescaper); end

    # source://rack/2.2.5/lib/rack/utils.rb#133
    def q_values(q_value_header); end

    # source://rack/2.2.5/lib/rack/utils.rb#332
    def rfc2109(time); end

    # source://rack/2.2.5/lib/rack/utils.rb#319
    def rfc2822(time); end

    # source://rack/2.2.5/lib/rack/utils.rb#380
    def secure_compare(a, b); end

    # source://rack/2.2.5/lib/rack/utils.rb#177
    def select_best_encoding(available_encodings, accept_encoding); end

    # source://rack/2.2.5/lib/rack/utils.rb#267
    def set_cookie_header!(header, key, value); end

    # source://rack/2.2.5/lib/rack/utils.rb#584
    def status_code(status); end

    # source://rack/2.2.5/lib/rack/utils.rb#56
    def unescape(s, encoding = T.unsafe(nil)); end

    # source://rack/2.2.5/lib/rack/utils.rb#50
    def unescape_path(s); end

    # source://rack/2.2.5/lib/rack/utils.rb#611
    def valid_path?(path); end
  end
end

# source://rack/2.2.5/lib/rack/utils.rb#22
Rack::Utils::COMMON_SEP = T.let(T.unsafe(nil), Hash)

class Rack::Utils::Context
  # source://rack/2.2.5/lib/rack/utils.rb#398
  def initialize(app_f, app_r); end

  # source://rack/2.2.5/lib/rack/utils.rb#396
  def app; end

  # source://rack/2.2.5/lib/rack/utils.rb#403
  def call(env); end

  # source://rack/2.2.5/lib/rack/utils.rb#411
  def context(env, app = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/utils.rb#396
  def for; end

  # source://rack/2.2.5/lib/rack/utils.rb#407
  def recontext(app); end
end

# source://rack/2.2.5/lib/rack/utils.rb#21
Rack::Utils::DEFAULT_SEP = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.5/lib/rack/utils.rb#161
Rack::Utils::ESCAPE_HTML = T.let(T.unsafe(nil), Hash)

# source://rack/2.2.5/lib/rack/utils.rb#170
Rack::Utils::ESCAPE_HTML_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.5/lib/rack/utils.rb#511
Rack::Utils::HTTP_STATUS_CODES = T.let(T.unsafe(nil), Hash)

class Rack::Utils::HeaderHash < ::Hash
  # source://rack/2.2.5/lib/rack/utils.rb#429
  def initialize(hash = T.unsafe(nil)); end

  # source://rack/2.2.5/lib/rack/utils.rb#459
  def [](k); end

  # source://rack/2.2.5/lib/rack/utils.rb#463
  def []=(k, v); end

  # source://rack/2.2.5/lib/rack/utils.rb#442
  def clear; end

  # source://rack/2.2.5/lib/rack/utils.rb#470
  def delete(k); end

  # source://rack/2.2.5/lib/rack/utils.rb#447
  def each; end

  # source://rack/2.2.5/lib/rack/utils.rb#476
  def has_key?(k); end

  # source://rack/2.2.5/lib/rack/utils.rb#476
  def include?(k); end

  # source://rack/2.2.5/lib/rack/utils.rb#476
  def key?(k); end

  # source://rack/2.2.5/lib/rack/utils.rb#476
  def member?(k); end

  # source://rack/2.2.5/lib/rack/utils.rb#489
  def merge(other); end

  # source://rack/2.2.5/lib/rack/utils.rb#484
  def merge!(other); end

  # source://rack/2.2.5/lib/rack/utils.rb#494
  def replace(other); end

  # source://rack/2.2.5/lib/rack/utils.rb#453
  def to_hash; end

  protected

  # source://rack/2.2.5/lib/rack/utils.rb#501
  def names; end

  private

  # source://rack/2.2.5/lib/rack/utils.rb#436
  def initialize_copy(other); end

  class << self
    # source://rack/2.2.5/lib/rack/utils.rb#421
    def [](headers); end
  end
end

# source://rack/2.2.5/lib/rack/utils.rb#20
Rack::Utils::InvalidParameterError = Rack::QueryParser::InvalidParameterError

# source://rack/2.2.5/lib/rack/utils.rb#23
Rack::Utils::KeySpaceConstrainedParams = Rack::QueryParser::Params

# source://rack/2.2.5/lib/rack/utils.rb#609
Rack::Utils::NULL_BYTE = T.let(T.unsafe(nil), String)

# source://rack/2.2.5/lib/rack/utils.rb#592
Rack::Utils::PATH_SEPS = T.let(T.unsafe(nil), Regexp)

# source://rack/2.2.5/lib/rack/utils.rb#19
Rack::Utils::ParameterTypeError = Rack::QueryParser::ParameterTypeError

# source://rack/2.2.5/lib/rack/utils.rb#25
Rack::Utils::RFC2822_DAY_NAME = T.let(T.unsafe(nil), Array)

# source://rack/2.2.5/lib/rack/utils.rb#26
Rack::Utils::RFC2822_MONTH_NAME = T.let(T.unsafe(nil), Array)

# source://rack/2.2.5/lib/rack/utils.rb#578
Rack::Utils::STATUS_WITH_NO_ENTITY_BODY = T.let(T.unsafe(nil), Hash)

# source://rack/2.2.5/lib/rack/utils.rb#580
Rack::Utils::SYMBOL_TO_STATUS_CODE = T.let(T.unsafe(nil), Hash)

# source://rack/2.2.5/lib/rack/version.rb#16
Rack::VERSION = T.let(T.unsafe(nil), Array)

module Sinatra
  class << self
    # Include the helper modules provided in Sinatra's request context.
    #
    # source://sinatra//lib/sinatra/base.rb#2028
    def helpers(*extensions, &block); end

    # Create a new Sinatra application; the block is evaluated in the class scope.
    #
    # source://sinatra//lib/sinatra/base.rb#2016
    def new(base = T.unsafe(nil), &block); end

    # Extend the top-level DSL with the modules provided.
    #
    # source://sinatra//lib/sinatra/base.rb#2023
    def register(*extensions, &block); end

    # Use the middleware for classic applications.
    #
    # source://sinatra//lib/sinatra/base.rb#2033
    def use(*args, &block); end
  end
end

# Execution context for classic style (top-level) applications. All
# DSL methods executed on main are delegated to this class.
#
# The Application class should not be subclassed, unless you want to
# inherit all settings, routes, handlers, and error pages from the
# top-level. Subclassing Sinatra::Base is highly recommended for
# modular applications.
class Sinatra::Application < ::Sinatra::Base
  class << self
    # source://sinatra//lib/sinatra/base.rb#1287
    def app_file; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def app_file=(val); end

    def app_file?; end

    # source://sinatra//lib/sinatra/base.rb#1951
    def logging; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def logging=(val); end

    def logging?; end
    def method_override; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def method_override=(val); end

    def method_override?; end

    # source://sinatra//lib/sinatra/base.rb#1956
    def register(*extensions, &block); end

    # source://sinatra//lib/sinatra/main.rb#36
    def run; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def run=(val); end

    def run?; end
  end
end

class Sinatra::BadRequest < ::Sinatra::Error
  # source://sinatra//lib/sinatra/base.rb#270
  def http_status; end
end

# Base class for all Sinatra applications and middleware.
class Sinatra::Base
  include ::Rack::Utils
  include ::Sinatra::Helpers
  include ::Sinatra::Templates

  # @return [Base] a new instance of Base
  # @yield [_self]
  # @yieldparam _self [Sinatra::Base] the object that the method was called on
  #
  # source://sinatra//lib/sinatra/base.rb#918
  def initialize(app = T.unsafe(nil), **_kwargs); end

  # Returns the value of attribute app.
  #
  # source://sinatra//lib/sinatra/base.rb#915
  def app; end

  # Sets the attribute app
  #
  # @param value the value to set the attribute app to.
  #
  # source://sinatra//lib/sinatra/base.rb#915
  def app=(_arg0); end

  # Rack call interface.
  #
  # source://sinatra//lib/sinatra/base.rb#927
  def call(env); end

  # source://sinatra//lib/sinatra/base.rb#931
  def call!(env); end

  # Returns the value of attribute env.
  #
  # source://sinatra//lib/sinatra/base.rb#915
  def env; end

  # Sets the attribute env
  #
  # @param value the value to set the attribute env to.
  #
  # source://sinatra//lib/sinatra/base.rb#915
  def env=(_arg0); end

  # Forward the request to the downstream app -- middleware only.
  #
  # source://sinatra//lib/sinatra/base.rb#978
  def forward; end

  # Exit the current block, halts any further processing
  # of the request, and returns the specified response.
  #
  # source://sinatra//lib/sinatra/base.rb#965
  def halt(*response); end

  # Returns the value of attribute params.
  #
  # source://sinatra//lib/sinatra/base.rb#915
  def params; end

  # Sets the attribute params
  #
  # @param value the value to set the attribute params to.
  #
  # source://sinatra//lib/sinatra/base.rb#915
  def params=(_arg0); end

  # Pass control to the next matching route.
  # If there are no more matching routes, Sinatra will
  # return a 404 response.
  #
  # source://sinatra//lib/sinatra/base.rb#973
  def pass(&block); end

  # Returns the value of attribute request.
  #
  # source://sinatra//lib/sinatra/base.rb#915
  def request; end

  # Sets the attribute request
  #
  # @param value the value to set the attribute request to.
  #
  # source://sinatra//lib/sinatra/base.rb#915
  def request=(_arg0); end

  # Returns the value of attribute response.
  #
  # source://sinatra//lib/sinatra/base.rb#915
  def response; end

  # Sets the attribute response
  #
  # @param value the value to set the attribute response to.
  #
  # source://sinatra//lib/sinatra/base.rb#915
  def response=(_arg0); end

  # Access settings defined with Base.set.
  #
  # source://sinatra//lib/sinatra/base.rb#959
  def settings; end

  # Returns the value of attribute template_cache.
  #
  # source://sinatra//lib/sinatra/base.rb#916
  def template_cache; end

  private

  # Dispatch a request with error handling.
  #
  # source://sinatra//lib/sinatra/base.rb#1114
  def dispatch!; end

  # source://sinatra//lib/sinatra/base.rb#1206
  def dump_errors!(boom); end

  # Find an custom error block for the key(s) specified.
  #
  # source://sinatra//lib/sinatra/base.rb#1187
  def error_block!(key, *block_params); end

  # Run filters defined on the class and all superclasses.
  # Accepts an optional block to call after each filter is applied.
  #
  # source://sinatra//lib/sinatra/base.rb#992
  def filter!(type, base = T.unsafe(nil), &block); end

  # source://sinatra//lib/sinatra/base.rb#1814
  def force_encoding(*args); end

  # Error handling during requests.
  #
  # source://sinatra//lib/sinatra/base.rb#1141
  def handle_exception!(boom); end

  # Run the block with 'throw :halt' support and apply result to the response.
  #
  # source://sinatra//lib/sinatra/base.rb#1098
  def invoke(&block); end

  # If the current request matches pattern and conditions, fill params
  # with keys and call the given block.
  # Revert params afterwards.
  #
  # Returns pass block.
  #
  # source://sinatra//lib/sinatra/base.rb#1035
  def process_route(pattern, conditions, block = T.unsafe(nil), values = T.unsafe(nil)); end

  # Run routes defined on the class and all superclasses.
  #
  # source://sinatra//lib/sinatra/base.rb#1001
  def route!(base = T.unsafe(nil), pass_block = T.unsafe(nil)); end

  # Run a route block and throw :halt with the result.
  #
  # source://sinatra//lib/sinatra/base.rb#1026
  def route_eval; end

  # No matching route was found or all routes passed. The default
  # implementation is to forward the request downstream when running
  # as middleware (@app is non-nil); when no downstream app is set, raise
  # a NotFound exception. Subclasses can override this method to perform
  # custom route miss logic.
  #
  # @raise [NotFound]
  #
  # source://sinatra//lib/sinatra/base.rb#1073
  def route_missing; end

  # Attempt to serve static files from public directory. Throws :halt when
  # a matching file is found, returns nil otherwise.
  #
  # source://sinatra//lib/sinatra/base.rb#1081
  def static!(options = T.unsafe(nil)); end

  class << self
    def absolute_redirects; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def absolute_redirects=(val); end

    def absolute_redirects?; end

    # source://sinatra//lib/sinatra/base.rb#1287
    def add_charset; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def add_charset=(val); end

    def add_charset?; end

    # add a filter
    #
    # source://sinatra//lib/sinatra/base.rb#1412
    def add_filter(type, path = T.unsafe(nil), **options, &block); end

    # Define an after filter; runs after all requests within the same
    # context as route handlers and may access/modify the request and
    # response.
    #
    # source://sinatra//lib/sinatra/base.rb#1407
    def after(path = T.unsafe(nil), **options, &block); end

    def app_file; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def app_file=(val); end

    def app_file?; end

    # Define a before filter; runs before all requests within the same
    # context as route handlers and may access/modify the request and
    # response.
    #
    # source://sinatra//lib/sinatra/base.rb#1400
    def before(path = T.unsafe(nil), **options, &block); end

    # source://sinatra//lib/sinatra/base.rb#1856
    def bind; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def bind=(val); end

    def bind?; end

    # Creates a Rack::Builder instance with all the middleware set up and
    # the given +app+ as end point.
    #
    # source://sinatra//lib/sinatra/base.rb#1557
    def build(app); end

    # source://sinatra//lib/sinatra/base.rb#1565
    def call(env); end

    # Like Kernel#caller but excluding certain magic entries and without
    # line / method information; the resulting array contains filenames only.
    #
    # source://sinatra//lib/sinatra/base.rb#1571
    def caller_files; end

    # source://sinatra//lib/sinatra/base.rb#1225
    def callers_to_ignore; end

    # Add a route condition. The route is considered non-matching when the
    # block returns false.
    #
    # source://sinatra//lib/sinatra/base.rb#1418
    def condition(name = T.unsafe(nil), &block); end

    # Set configuration options for Sinatra and/or the app.
    # Allows scoping of settings for certain environments.
    #
    # @yield [_self]
    # @yieldparam _self [Sinatra::Base] the object that the method was called on
    #
    # source://sinatra//lib/sinatra/base.rb#1485
    def configure(*envs); end

    # source://sinatra//lib/sinatra/base.rb#1287
    def default_content_type; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def default_content_type=(val); end

    def default_content_type?; end

    # source://sinatra//lib/sinatra/base.rb#1287
    def default_encoding; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def default_encoding=(val); end

    def default_encoding?; end

    # source://sinatra//lib/sinatra/base.rb#1449
    def delete(path, opts = T.unsafe(nil), &block); end

    # @return [Boolean]
    #
    # source://sinatra//lib/sinatra/base.rb#1479
    def development?; end

    # Same as calling `set :option, false` for each of the given options.
    #
    # source://sinatra//lib/sinatra/base.rb#1313
    def disable(*opts); end

    # source://sinatra//lib/sinatra/base.rb#1822
    def dump_errors; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def dump_errors=(val); end

    def dump_errors?; end
    def empty_path_info; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def empty_path_info=(val); end

    def empty_path_info?; end

    # Same as calling `set :option, true` for each of the given options.
    #
    # source://sinatra//lib/sinatra/base.rb#1308
    def enable(*opts); end

    def environment; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def environment=(val); end

    def environment?; end

    # Define a custom error handler. Optionally takes either an Exception
    # class, or an HTTP status code to specify which errors should be
    # handled.
    #
    # source://sinatra//lib/sinatra/base.rb#1320
    def error(*codes, &block); end

    # Returns the value of attribute errors.
    #
    # source://sinatra//lib/sinatra/base.rb#1223
    def errors; end

    # Extension modules registered on this class and all superclasses.
    #
    # source://sinatra//lib/sinatra/base.rb#1248
    def extensions; end

    # Returns the value of attribute filters.
    #
    # source://sinatra//lib/sinatra/base.rb#1223
    def filters; end

    # Force data to specified encoding. It defaults to settings.default_encoding
    # which is UTF-8 by default
    #
    # source://sinatra//lib/sinatra/base.rb#1801
    def force_encoding(data, encoding = T.unsafe(nil)); end

    # Defining a `GET` handler also automatically defines
    # a `HEAD` handler.
    #
    # source://sinatra//lib/sinatra/base.rb#1437
    def get(path, opts = T.unsafe(nil), &block); end

    def handler_name; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def handler_name=(val); end

    def handler_name?; end

    # source://sinatra//lib/sinatra/base.rb#1451
    def head(path, opts = T.unsafe(nil), &block); end

    # Makes the methods defined in the block and in the Modules given
    # in `extensions` available to the handlers and templates
    #
    # source://sinatra//lib/sinatra/base.rb#1463
    def helpers(*extensions, &block); end

    # Load embedded templates from the file; uses the caller's __FILE__
    # when no file is specified.
    #
    # source://sinatra//lib/sinatra/base.rb#1346
    def inline_templates=(file = T.unsafe(nil)); end

    # Define the layout template. The block must return the template source.
    #
    # source://sinatra//lib/sinatra/base.rb#1340
    def layout(name = T.unsafe(nil), &block); end

    # source://sinatra//lib/sinatra/base.rb#1457
    def link(path, opts = T.unsafe(nil), &block); end

    def lock; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def lock=(val); end

    def lock?; end
    def logging; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def logging=(val); end

    def logging?; end
    def method_override; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def method_override=(val); end

    def method_override?; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def methodoverride=(val); end

    def methodoverride?; end

    # Middleware used in this class and all superclasses.
    #
    # source://sinatra//lib/sinatra/base.rb#1257
    def middleware; end

    # Lookup or register a mime type in Rack's mime registry.
    #
    # source://sinatra//lib/sinatra/base.rb#1379
    def mime_type(type, value = T.unsafe(nil)); end

    # provides all mime types matching type, including deprecated types:
    #   mime_types :html # => ['text/html']
    #   mime_types :js   # => ['application/javascript', 'text/javascript']
    #
    # source://sinatra//lib/sinatra/base.rb#1392
    def mime_types(type); end

    # source://sinatra//lib/sinatra/base.rb#1287
    def mustermann_opts; end

    # source://sinatra//lib/sinatra/base.rb#1295
    def mustermann_opts=(val); end

    def mustermann_opts?; end

    # Create a new instance of the class fronted by its middleware
    # pipeline. The object is guaranteed to respond to #call but may not be
    # an instance of the class new was called on.
    #
    # source://sinatra//lib/sinatra/base.rb#1549
    def new(*args, **_arg1, &block); end

    def new!(*_arg0); end

    # Sugar for `error(404) { ... }`
    #
    # source://sinatra//lib/sinatra/base.rb#1329
    def not_found(&block); end

    # source://sinatra//lib/sinatra/base.rb#1453
    def options(path, opts = T.unsafe(nil), &block); end

    # source://sinatra//lib/sinatra/base.rb#1455
    def patch(path, opts = T.unsafe(nil), &block); end

    def port; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def port=(val); end

    def port?; end

    # source://sinatra//lib/sinatra/base.rb#1447
    def post(path, opts = T.unsafe(nil), &block); end

    def prefixed_redirects; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def prefixed_redirects=(val); end

    def prefixed_redirects?; end

    # @return [Boolean]
    #
    # source://sinatra//lib/sinatra/base.rb#1480
    def production?; end

    def protection; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def protection=(val); end

    def protection?; end

    # The prototype instance used to process requests.
    #
    # source://sinatra//lib/sinatra/base.rb#1539
    def prototype; end

    # source://sinatra//lib/sinatra/base.rb#1422
    def public=(value); end

    # source://sinatra//lib/sinatra/base.rb#1431
    def public_dir; end

    # source://sinatra//lib/sinatra/base.rb#1427
    def public_dir=(value); end

    # source://sinatra//lib/sinatra/base.rb#1880
    def public_folder; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def public_folder=(val); end

    def public_folder?; end

    # source://sinatra//lib/sinatra/base.rb#1445
    def put(path, opts = T.unsafe(nil), &block); end

    def quiet; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def quiet=(val); end

    def quiet?; end

    # Stop the self-hosted server if running.
    #
    # source://sinatra//lib/sinatra/base.rb#1497
    def quit!; end

    # source://sinatra//lib/sinatra/base.rb#1821
    def raise_errors; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def raise_errors=(val); end

    def raise_errors?; end

    # Register an extension. Alternatively take a block from which an
    # extension will be created and registered on the fly.
    #
    # source://sinatra//lib/sinatra/base.rb#1470
    def register(*extensions, &block); end

    # source://sinatra//lib/sinatra/base.rb#1876
    def reload_templates; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def reload_templates=(val); end

    def reload_templates?; end

    # Removes all routes, filters, middleware and extension hooks from the
    # current class (not routes/filters/... defined by its superclass).
    #
    # source://sinatra//lib/sinatra/base.rb#1231
    def reset!; end

    # source://sinatra//lib/sinatra/base.rb#1874
    def root; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def root=(val); end

    def root?; end

    # Returns the value of attribute routes.
    #
    # source://sinatra//lib/sinatra/base.rb#1223
    def routes; end

    def run; end

    # Run the Sinatra app as a self-hosted server using
    # Puma, Falcon, Mongrel, or WEBrick (in that order). If given a block, will call
    # with the constructed handler once we have taken the stage.
    #
    # source://sinatra//lib/sinatra/base.rb#1512
    def run!(options = T.unsafe(nil), &block); end

    # source://sinatra//lib/sinatra/base.rb#1286
    def run=(val); end

    def run?; end

    # Check whether the self-hosted server is running or not.
    #
    # @return [Boolean]
    #
    # source://sinatra//lib/sinatra/base.rb#1534
    def running?; end

    def running_server; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def running_server=(val); end

    def running_server?; end

    # source://sinatra//lib/sinatra/base.rb#1287
    def server; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def server=(val); end

    def server?; end

    # source://sinatra//lib/sinatra/base.rb#1287
    def session_secret; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def session_secret=(val); end

    def session_secret?; end

    # source://sinatra//lib/sinatra/base.rb#1287
    def session_store; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def session_store=(val); end

    def session_store?; end
    def sessions; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def sessions=(val); end

    def sessions?; end

    # Sets an option to the given value.  If the value is a proc,
    # the proc will be called every time the option is accessed.
    #
    # @raise [ArgumentError]
    #
    # source://sinatra//lib/sinatra/base.rb#1267
    def set(option, value = T.unsafe(nil), ignore_setter = T.unsafe(nil), &block); end

    # Access settings defined with Base.set.
    #
    # source://sinatra//lib/sinatra/base.rb#954
    def settings; end

    # source://sinatra//lib/sinatra/base.rb#1823
    def show_exceptions; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def show_exceptions=(val); end

    def show_exceptions?; end

    # Run the Sinatra app as a self-hosted server using
    # Puma, Falcon, Mongrel, or WEBrick (in that order). If given a block, will call
    # with the constructed handler once we have taken the stage.
    #
    # source://sinatra//lib/sinatra/base.rb#1512
    def start!(options = T.unsafe(nil), &block); end

    # source://sinatra//lib/sinatra/base.rb#1881
    def static; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def static=(val); end

    def static?; end
    def static_cache_control; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def static_cache_control=(val); end

    def static_cache_control?; end

    # Stop the self-hosted server if running.
    #
    # source://sinatra//lib/sinatra/base.rb#1497
    def stop!; end

    def strict_paths; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def strict_paths=(val); end

    def strict_paths?; end

    # Define a named template. The block must return the template source.
    #
    # source://sinatra//lib/sinatra/base.rb#1334
    def template(name, &block); end

    # Returns the value of attribute templates.
    #
    # source://sinatra//lib/sinatra/base.rb#1223
    def templates; end

    # @return [Boolean]
    #
    # source://sinatra//lib/sinatra/base.rb#1481
    def test?; end

    def threaded; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def threaded=(val); end

    def threaded?; end
    def traps; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def traps=(val); end

    def traps?; end

    # source://sinatra//lib/sinatra/base.rb#1459
    def unlink(path, opts = T.unsafe(nil), &block); end

    # Use the specified Rack middleware
    #
    # source://sinatra//lib/sinatra/base.rb#1490
    def use(middleware, *args, **_arg2, &block); end

    def use_code; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def use_code=(val); end

    def use_code?; end

    # source://sinatra//lib/sinatra/base.rb#1875
    def views; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def views=(val); end

    def views?; end
    def x_cascade; end

    # source://sinatra//lib/sinatra/base.rb#1286
    def x_cascade=(val); end

    def x_cascade?; end

    private

    # Condition for matching user agent. Parameter should be Regexp.
    # Will set params[:agent].
    #
    # source://sinatra//lib/sinatra/base.rb#1631
    def agent(pattern); end

    # Like Kernel#caller but excluding certain magic entries
    #
    # source://sinatra//lib/sinatra/base.rb#1792
    def cleaned_caller(keep = T.unsafe(nil)); end

    # source://sinatra//lib/sinatra/base.rb#1702
    def compile(path, route_mustermann_opts = T.unsafe(nil)); end

    # source://sinatra//lib/sinatra/base.rb#1682
    def compile!(verb, path, block, **options); end

    # Dynamically defines a method on settings.
    #
    # source://sinatra//lib/sinatra/base.rb#1617
    def define_singleton(name, content = T.unsafe(nil)); end

    # source://sinatra//lib/sinatra/base.rb#1675
    def generate_method(method_name, &block); end

    # Condition for matching host name. Parameter might be String or Regexp.
    #
    # source://sinatra//lib/sinatra/base.rb#1625
    def host_name(pattern); end

    # @private
    #
    # source://sinatra//lib/sinatra/base.rb#1771
    def inherited(subclass); end

    # source://sinatra//lib/sinatra/base.rb#1671
    def invoke_hook(name, *args); end

    # Condition for matching mimetypes. Accepts file extensions.
    #
    # source://sinatra//lib/sinatra/base.rb#1644
    def provides(*types); end

    # source://sinatra//lib/sinatra/base.rb#1663
    def route(verb, path, options = T.unsafe(nil), &block); end

    # source://sinatra//lib/sinatra/base.rb#1733
    def setup_common_logger(builder); end

    # source://sinatra//lib/sinatra/base.rb#1737
    def setup_custom_logger(builder); end

    # source://sinatra//lib/sinatra/base.rb#1706
    def setup_default_middleware(builder); end

    # source://sinatra//lib/sinatra/base.rb#1720
    def setup_logging(builder); end

    # source://sinatra//lib/sinatra/base.rb#1716
    def setup_middleware(builder); end

    # source://sinatra//lib/sinatra/base.rb#1729
    def setup_null_logger(builder); end

    # source://sinatra//lib/sinatra/base.rb#1745
    def setup_protection(builder); end

    # source://sinatra//lib/sinatra/base.rb#1762
    def setup_sessions(builder); end

    # source://sinatra//lib/sinatra/base.rb#1601
    def setup_traps; end

    # Starts the server by running the Rack Handler.
    #
    # source://sinatra//lib/sinatra/base.rb#1578
    def start_server(handler, server_settings, handler_name); end

    # @return [Boolean]
    #
    # source://sinatra//lib/sinatra/base.rb#1597
    def suppress_messages?; end

    # source://sinatra//lib/sinatra/base.rb#1778
    def synchronize(&block); end

    # Condition for matching user agent. Parameter should be Regexp.
    # Will set params[:agent].
    #
    # source://sinatra//lib/sinatra/base.rb#1631
    def user_agent(pattern); end

    # used for deprecation warnings
    #
    # source://sinatra//lib/sinatra/base.rb#1787
    def warn_for_deprecation(message); end
  end
end

# source://sinatra//lib/sinatra/base.rb#913
Sinatra::Base::URI_INSTANCE = T.let(T.unsafe(nil), URI::RFC2396_Parser)

# Behaves exactly like Rack::CommonLogger with the notable exception that it does nothing,
# if another CommonLogger is already in the middleware chain.
class Sinatra::CommonLogger < ::Rack::CommonLogger
  # source://sinatra//lib/sinatra/base.rb#253
  def call(env); end
end

# Sinatra delegation mixin. Mixing this module into an object causes all
# methods to be delegated to the Sinatra::Application class. Used primarily
# at the top-level.
module Sinatra::Delegator
  private

  # source://sinatra//lib/sinatra/base.rb#1969
  def after(*args, **_arg1, &block); end

  # source://sinatra//lib/sinatra/base.rb#1969
  def before(*args, **_arg1, &block); end

  # source://sinatra//lib/sinatra/base.rb#1969
  def configure(*args, **_arg1, &block); end

  # source://sinatra//lib/sinatra/base.rb#1969
  def delete(*args, **_arg1, &block); end

  # source://sinatra//lib/sinatra/base.rb#1969
  def development?(*args, **_arg1, &block); end

  # source://sinatra//lib/sinatra/base.rb#1969
  def disable(*args, **_arg1, &block); end

  # source://sinatra//lib/sinatra/base.rb#1969
  def enable(*args, **_arg1, &block); end

  # source://sinatra//lib/sinatra/base.rb#1969
  def error(*args, **_arg1, &block); end

  # source://sinatra//lib/sinatra/base.rb#1969
  def get(*args, **_arg1, &block); end

  # source://sinatra//lib/sinatra/base.rb#1969
  def head(*args, **_arg1, &block); end

  # source://sinatra//lib/sinatra/base.rb#1969
  def helpers(*args, **_arg1, &block); end

  # source://sinatra//lib/sinatra/base.rb#1969
  def layout(*args, **_arg1, &block); end

  # source://sinatra//lib/sinatra/base.rb#1969
  def link(*args, **_arg1, &block); end

  # source://sinatra//lib/sinatra/base.rb#1969
  def mime_type(*args, **_arg1, &block); end

  # source://sinatra//lib/sinatra/base.rb#1969
  def not_found(*args, **_arg1, &block); end

  # source://sinatra//lib/sinatra/base.rb#1969
  def options(*args, **_arg1, &block); end

  # source://sinatra//lib/sinatra/base.rb#1969
  def patch(*args, **_arg1, &block); end

  # source://sinatra//lib/sinatra/base.rb#1969
  def post(*args, **_arg1, &block); end

  # source://sinatra//lib/sinatra/base.rb#1969
  def production?(*args, **_arg1, &block); end

  # source://sinatra//lib/sinatra/base.rb#1969
  def put(*args, **_arg1, &block); end

  # source://sinatra//lib/sinatra/base.rb#1969
  def register(*args, **_arg1, &block); end

  # source://sinatra//lib/sinatra/base.rb#1969
  def set(*args, **_arg1, &block); end

  # source://sinatra//lib/sinatra/base.rb#1969
  def settings(*args, **_arg1, &block); end

  # source://sinatra//lib/sinatra/base.rb#1969
  def template(*args, **_arg1, &block); end

  # source://sinatra//lib/sinatra/base.rb#1969
  def test?(*args, **_arg1, &block); end

  # source://sinatra//lib/sinatra/base.rb#1969
  def unlink(*args, **_arg1, &block); end

  # source://sinatra//lib/sinatra/base.rb#1969
  def use(*args, **_arg1, &block); end

  class << self
    # source://sinatra//lib/sinatra/base.rb#1967
    def delegate(*methods); end

    # Returns the value of attribute target.
    #
    # source://sinatra//lib/sinatra/base.rb#1986
    def target; end

    # Sets the attribute target
    #
    # @param value the value to set the attribute target to.
    #
    # source://sinatra//lib/sinatra/base.rb#1986
    def target=(_arg0); end
  end
end

class Sinatra::Error < ::StandardError; end

# Some Rack handlers (Rainbows!) implement an extended body object protocol, however,
# some middleware (namely Rack::Lint) will break it by not mirroring the methods in question.
# This middleware will detect an extended body object and will make sure it reaches the
# handler directly. We do this here, so our middleware and middleware set up by the app will
# still be able to run.
class Sinatra::ExtendedRack < ::Struct
  # source://sinatra//lib/sinatra/base.rb#218
  def call(env); end

  private

  # @raise [NotImplementedError]
  #
  # source://sinatra//lib/sinatra/base.rb#237
  def after_response(&block); end

  # @return [Boolean]
  #
  # source://sinatra//lib/sinatra/base.rb#243
  def async?(status, _headers, body); end

  # source://sinatra//lib/sinatra/base.rb#230
  def setup_close(env, _status, _headers, body); end
end

# Methods available to routes, before/after filters, and views.
module Sinatra::Helpers
  # Set the Content-Disposition to "attachment" with the specified filename,
  # instructing the user agents to prompt to save.
  #
  # source://sinatra//lib/sinatra/base.rb#408
  def attachment(filename = T.unsafe(nil), disposition = T.unsafe(nil)); end

  # Sugar for redirect (example:  redirect back)
  #
  # source://sinatra//lib/sinatra/base.rb#635
  def back; end

  # whether or not the status is set to 400
  #
  # @return [Boolean]
  #
  # source://sinatra//lib/sinatra/base.rb#670
  def bad_request?; end

  # Set or retrieve the response body. When a block is given,
  # evaluation is deferred until the body is read with #each.
  #
  # source://sinatra//lib/sinatra/base.rb#287
  def body(value = T.unsafe(nil), &block); end

  # Specify response freshness policy for HTTP caches (Cache-Control header).
  # Any number of non-value directives (:public, :private, :no_cache,
  # :no_store, :must_revalidate, :proxy_revalidate) may be passed along with
  # a Hash of value directives (:max_age, :s_maxage).
  #
  #   cache_control :public, :must_revalidate, :max_age => 60
  #   => Cache-Control: public, must-revalidate, max-age=60
  #
  # See RFC 2616 / 14.9 for more on standard cache control directives:
  # http://tools.ietf.org/html/rfc2616#section-14.9.1
  #
  # source://sinatra//lib/sinatra/base.rb#522
  def cache_control(*values); end

  # whether or not the status is set to 4xx
  #
  # @return [Boolean]
  #
  # source://sinatra//lib/sinatra/base.rb#655
  def client_error?; end

  # Set the Content-Type of the response body given a media type or file
  # extension.
  #
  # source://sinatra//lib/sinatra/base.rb#377
  def content_type(type = T.unsafe(nil), params = T.unsafe(nil)); end

  # Halt processing and return the error status provided.
  #
  # source://sinatra//lib/sinatra/base.rb#340
  def error(code, body = T.unsafe(nil)); end

  # Set the response entity tag (HTTP 'ETag' header) and halt if conditional
  # GET matches. The +value+ argument is an identifier that uniquely
  # identifies the current version of the resource. The +kind+ argument
  # indicates whether the etag should be used as a :strong (default) or :weak
  # cache validator.
  #
  # When the current request includes an 'If-None-Match' header with a
  # matching etag, execution is immediately halted. If the request method is
  # GET or HEAD, a '304 Not Modified' response is sent.
  #
  # source://sinatra//lib/sinatra/base.rb#605
  def etag(value, options = T.unsafe(nil)); end

  # Set the Expires header and Cache-Control/max-age directive. Amount
  # can be an integer number of seconds in the future or a Time object
  # indicating when the response should be considered "stale". The remaining
  # "values" arguments are passed to the #cache_control helper:
  #
  #   expires 500, :public, :must_revalidate
  #   => Cache-Control: public, must-revalidate, max-age=500
  #   => Expires: Mon, 08 Jun 2009 08:50:17 GMT
  #
  # source://sinatra//lib/sinatra/base.rb#550
  def expires(amount, *values); end

  # Set multiple response headers with Hash.
  #
  # source://sinatra//lib/sinatra/base.rb#355
  def headers(hash = T.unsafe(nil)); end

  # whether or not the status is set to 1xx
  #
  # @return [Boolean]
  #
  # source://sinatra//lib/sinatra/base.rb#640
  def informational?; end

  # Set the last modified time of the resource (HTTP 'Last-Modified' header)
  # and halt if conditional GET matches. The +time+ argument is a Time,
  # DateTime, or other object that responds to +to_time+.
  #
  # When the current request includes an 'If-Modified-Since' header that is
  # equal or later than the time specified, execution is immediately halted
  # with a '304 Not Modified' response.
  #
  # source://sinatra//lib/sinatra/base.rb#574
  def last_modified(time); end

  # Access shared logger object.
  #
  # source://sinatra//lib/sinatra/base.rb#366
  def logger; end

  # Look up a media type by file extension in Rack's mime registry.
  #
  # source://sinatra//lib/sinatra/base.rb#371
  def mime_type(type); end

  # Halt processing and return a 404 Not Found.
  #
  # source://sinatra//lib/sinatra/base.rb#350
  def not_found(body = T.unsafe(nil)); end

  # whether or not the status is set to 404
  #
  # @return [Boolean]
  #
  # source://sinatra//lib/sinatra/base.rb#665
  def not_found?; end

  # Halt processing and redirect to the URI provided.
  #
  # source://sinatra//lib/sinatra/base.rb#304
  def redirect(uri, *args); end

  # whether or not the status is set to 3xx
  #
  # @return [Boolean]
  #
  # source://sinatra//lib/sinatra/base.rb#650
  def redirect?; end

  # Use the contents of the file at +path+ as the response body.
  #
  # source://sinatra//lib/sinatra/base.rb#419
  def send_file(path, opts = T.unsafe(nil)); end

  # whether or not the status is set to 5xx
  #
  # @return [Boolean]
  #
  # source://sinatra//lib/sinatra/base.rb#660
  def server_error?; end

  # Access the underlying Rack session.
  #
  # source://sinatra//lib/sinatra/base.rb#361
  def session; end

  # Set or retrieve the response status code.
  #
  # source://sinatra//lib/sinatra/base.rb#280
  def status(value = T.unsafe(nil)); end

  # Allows to start sending data to the client even though later parts of
  # the response body have not yet been generated.
  #
  # The close parameter specifies whether Stream#close should be called
  # after the block has been executed. This is only relevant for evented
  # servers like Rainbows.
  #
  # source://sinatra//lib/sinatra/base.rb#506
  def stream(keep_open = T.unsafe(nil)); end

  # whether or not the status is set to 2xx
  #
  # @return [Boolean]
  #
  # source://sinatra//lib/sinatra/base.rb#645
  def success?; end

  # Generates a Time object from the given value.
  # Used by #expires and #last_modified.
  #
  # source://sinatra//lib/sinatra/base.rb#676
  def time_for(value); end

  # Generates the absolute URI for a given path in the app.
  # Takes Rack routers and reverse proxies into account.
  #
  # source://sinatra//lib/sinatra/base.rb#319
  def to(addr = T.unsafe(nil), absolute = T.unsafe(nil), add_script_name = T.unsafe(nil)); end

  # Generates the absolute URI for a given path in the app.
  # Takes Rack routers and reverse proxies into account.
  #
  # source://sinatra//lib/sinatra/base.rb#319
  def uri(addr = T.unsafe(nil), absolute = T.unsafe(nil), add_script_name = T.unsafe(nil)); end

  # Generates the absolute URI for a given path in the app.
  # Takes Rack routers and reverse proxies into account.
  #
  # source://sinatra//lib/sinatra/base.rb#319
  def url(addr = T.unsafe(nil), absolute = T.unsafe(nil), add_script_name = T.unsafe(nil)); end

  private

  # Helper method checking if a ETag value list includes the current ETag.
  #
  # @return [Boolean]
  #
  # source://sinatra//lib/sinatra/base.rb#693
  def etag_matches?(list, new_resource = T.unsafe(nil)); end

  # source://sinatra//lib/sinatra/base.rb#699
  def with_params(temp_params); end
end

# source://sinatra//lib/sinatra/base.rb#595
Sinatra::Helpers::ETAG_KINDS = T.let(T.unsafe(nil), Array)

# https://html.spec.whatwg.org/#multipart-form-data
#
# source://sinatra//lib/sinatra/base.rb#400
Sinatra::Helpers::MULTIPART_FORM_DATA_REPLACEMENT_TABLE = T.let(T.unsafe(nil), Hash)

# Class of the response body in case you use #stream.
#
# Three things really matter: The front and back block (back being the
# block generating content, front the one sending it to the client) and
# the scheduler, integrating with whatever concurrency feature the Rack
# handler is using.
#
# Scheduler has to respond to defer and schedule.
class Sinatra::Helpers::Stream
  # @return [Stream] a new instance of Stream
  #
  # source://sinatra//lib/sinatra/base.rb#455
  def initialize(scheduler = T.unsafe(nil), keep_open = T.unsafe(nil), &back); end

  # source://sinatra//lib/sinatra/base.rb#482
  def <<(data); end

  # source://sinatra//lib/sinatra/base.rb#487
  def callback(&block); end

  # source://sinatra//lib/sinatra/base.rb#463
  def close; end

  # @return [Boolean]
  #
  # source://sinatra//lib/sinatra/base.rb#495
  def closed?; end

  # source://sinatra//lib/sinatra/base.rb#470
  def each(&front); end

  # source://sinatra//lib/sinatra/base.rb#487
  def errback(&block); end

  class << self
    # source://sinatra//lib/sinatra/base.rb#453
    def defer(*_arg0); end

    # source://sinatra//lib/sinatra/base.rb#452
    def schedule(*_arg0); end
  end
end

# A poor man's ActiveSupport::HashWithIndifferentAccess, with all the Rails-y
# stuff removed.
#
# Implements a hash where keys <tt>:foo</tt> and <tt>"foo"</tt> are
# considered to be the same.
#
#   rgb = Sinatra::IndifferentHash.new
#
#   rgb[:black]    =  '#000000' # symbol assignment
#   rgb[:black]  # => '#000000' # symbol retrieval
#   rgb['black'] # => '#000000' # string retrieval
#
#   rgb['white']   =  '#FFFFFF' # string assignment
#   rgb[:white]  # => '#FFFFFF' # symbol retrieval
#   rgb['white'] # => '#FFFFFF' # string retrieval
#
# Internally, symbols are mapped to strings when used as keys in the entire
# writing interface (calling e.g. <tt>[]=</tt>, <tt>merge</tt>). This mapping
# belongs to the public interface. For example, given:
#
#   hash = Sinatra::IndifferentHash.new(:a=>1)
#
# You are guaranteed that the key is returned as a string:
#
#   hash.keys # => ["a"]
#
# Technically other types of keys are accepted:
#
#   hash = Sinatra::IndifferentHash.new(:a=>1)
#   hash[0] = 0
#   hash # => { "a"=>1, 0=>0 }
#
# But this class is intended for use cases where strings or symbols are the
# expected keys and it is convenient to understand both as the same. For
# example the +params+ hash in Sinatra.
class Sinatra::IndifferentHash < ::Hash
  # @return [IndifferentHash] a new instance of IndifferentHash
  #
  # source://sinatra//lib/sinatra/indifferent_hash.rb#44
  def initialize(*args); end

  # source://sinatra//lib/sinatra/indifferent_hash.rb#74
  def [](key); end

  # source://sinatra//lib/sinatra/indifferent_hash.rb#78
  def []=(key, value); end

  # source://sinatra//lib/sinatra/indifferent_hash.rb#60
  def assoc(key); end

  # source://sinatra//lib/sinatra/indifferent_hash.rb#185
  def compact; end

  # source://sinatra//lib/sinatra/indifferent_hash.rb#50
  def default(*args); end

  # source://sinatra//lib/sinatra/indifferent_hash.rb#56
  def default=(value); end

  # source://sinatra//lib/sinatra/indifferent_hash.rb#102
  def delete(key); end

  # Added in Ruby 2.3
  #
  # source://sinatra//lib/sinatra/indifferent_hash.rb#107
  def dig(key, *other_keys); end

  # source://sinatra//lib/sinatra/indifferent_hash.rb#68
  def fetch(key, *args); end

  # source://sinatra//lib/sinatra/indifferent_hash.rb#111
  def fetch_values(*keys); end

  # @return [Boolean]
  #
  # source://sinatra//lib/sinatra/indifferent_hash.rb#88
  def has_key?(key); end

  # @return [Boolean]
  #
  # source://sinatra//lib/sinatra/indifferent_hash.rb#96
  def has_value?(value); end

  # @return [Boolean]
  #
  # source://sinatra//lib/sinatra/indifferent_hash.rb#88
  def include?(key); end

  # source://sinatra//lib/sinatra/indifferent_hash.rb#84
  def key(value); end

  # @return [Boolean]
  #
  # source://sinatra//lib/sinatra/indifferent_hash.rb#88
  def key?(key); end

  # @return [Boolean]
  #
  # source://sinatra//lib/sinatra/indifferent_hash.rb#88
  def member?(key); end

  # source://sinatra//lib/sinatra/indifferent_hash.rb#147
  def merge(*other_hashes, &block); end

  # source://sinatra//lib/sinatra/indifferent_hash.rb#129
  def merge!(*other_hashes); end

  # source://sinatra//lib/sinatra/indifferent_hash.rb#64
  def rassoc(value); end

  # source://sinatra//lib/sinatra/indifferent_hash.rb#179
  def reject(*args, &block); end

  # source://sinatra//lib/sinatra/indifferent_hash.rb#151
  def replace(other_hash); end

  # source://sinatra//lib/sinatra/indifferent_hash.rb#173
  def select(*args, &block); end

  # source://sinatra//lib/sinatra/indifferent_hash.rb#117
  def slice(*keys); end

  # source://sinatra//lib/sinatra/indifferent_hash.rb#78
  def store(key, value); end

  # source://sinatra//lib/sinatra/indifferent_hash.rb#164
  def transform_keys(&block); end

  # source://sinatra//lib/sinatra/indifferent_hash.rb#168
  def transform_keys!; end

  # source://sinatra//lib/sinatra/indifferent_hash.rb#155
  def transform_values(&block); end

  # source://sinatra//lib/sinatra/indifferent_hash.rb#159
  def transform_values!; end

  # source://sinatra//lib/sinatra/indifferent_hash.rb#129
  def update(*other_hashes); end

  # @return [Boolean]
  #
  # source://sinatra//lib/sinatra/indifferent_hash.rb#96
  def value?(value); end

  # source://sinatra//lib/sinatra/indifferent_hash.rb#123
  def values_at(*keys); end

  private

  # source://sinatra//lib/sinatra/indifferent_hash.rb#191
  def convert_key(key); end

  # source://sinatra//lib/sinatra/indifferent_hash.rb#195
  def convert_value(value); end

  class << self
    # source://sinatra//lib/sinatra/indifferent_hash.rb#40
    def [](*args); end
  end
end

class Sinatra::NotFound < ::Sinatra::Error
  # source://sinatra//lib/sinatra/base.rb#274
  def http_status; end
end

# The request object. See Rack::Request for more info:
# http://rubydoc.info/github/rack/rack/master/Rack/Request
class Sinatra::Request < ::Rack::Request
  # Returns an array of acceptable media types for the response
  #
  # source://sinatra//lib/sinatra/base.rb#28
  def accept; end

  # @return [Boolean]
  #
  # source://sinatra//lib/sinatra/base.rb#40
  def accept?(type); end

  # @return [Boolean]
  #
  # source://sinatra//lib/sinatra/base.rb#58
  def forwarded?; end

  # @return [Boolean]
  #
  # source://sinatra//lib/sinatra/base.rb#66
  def idempotent?; end

  # @return [Boolean]
  #
  # source://sinatra//lib/sinatra/base.rb#70
  def link?; end

  # source://sinatra//lib/sinatra/base.rb#78
  def params; end

  # source://sinatra//lib/sinatra/base.rb#44
  def preferred_type(*types); end

  # @return [Boolean]
  #
  # source://sinatra//lib/sinatra/base.rb#62
  def safe?; end

  # source://rack/2.2.5/lib/rack/request.rb#350
  def secure?; end

  # @return [Boolean]
  #
  # source://sinatra//lib/sinatra/base.rb#74
  def unlink?; end
end

class Sinatra::Request::AcceptEntry
  # @return [AcceptEntry] a new instance of AcceptEntry
  #
  # source://sinatra//lib/sinatra/base.rb#90
  def initialize(entry); end

  # source://sinatra//lib/sinatra/base.rb#103
  def <=>(other); end

  # Returns the value of attribute entry.
  #
  # source://sinatra//lib/sinatra/base.rb#88
  def entry; end

  # source://sinatra//lib/sinatra/base.rb#124
  def method_missing(*args, &block); end

  # Returns the value of attribute params.
  #
  # source://sinatra//lib/sinatra/base.rb#87
  def params; end

  # Sets the attribute params
  #
  # @param value the value to set the attribute params to.
  #
  # source://sinatra//lib/sinatra/base.rb#87
  def params=(_arg0); end

  # source://sinatra//lib/sinatra/base.rb#107
  def priority; end

  # @return [Boolean]
  #
  # source://sinatra//lib/sinatra/base.rb#120
  def respond_to?(*args); end

  # source://sinatra//lib/sinatra/base.rb#116
  def to_s(full = T.unsafe(nil)); end

  # source://sinatra//lib/sinatra/base.rb#112
  def to_str; end
end

# source://sinatra//lib/sinatra/base.rb#24
Sinatra::Request::HEADER_PARAM = T.let(T.unsafe(nil), Regexp)

# source://sinatra//lib/sinatra/base.rb#25
Sinatra::Request::HEADER_VALUE_WITH_PARAMS = T.let(T.unsafe(nil), Regexp)

class Sinatra::Request::MimeTypeEntry
  # @return [MimeTypeEntry] a new instance of MimeTypeEntry
  #
  # source://sinatra//lib/sinatra/base.rb#132
  def initialize(entry); end

  # @return [Boolean]
  #
  # source://sinatra//lib/sinatra/base.rb#143
  def accepts?(entry); end

  # @return [Boolean]
  #
  # source://sinatra//lib/sinatra/base.rb#151
  def matches_params?(params); end

  # Returns the value of attribute params.
  #
  # source://sinatra//lib/sinatra/base.rb#130
  def params; end

  # source://sinatra//lib/sinatra/base.rb#147
  def to_str; end
end

# The response object. See Rack::Response and Rack::Response::Helpers for
# more info:
# http://rubydoc.info/github/rack/rack/master/Rack/Response
# http://rubydoc.info/github/rack/rack/master/Rack/Response/Helpers
class Sinatra::Response < ::Rack::Response
  # source://sinatra//lib/sinatra/base.rb#166
  def body=(value); end

  # source://sinatra//lib/sinatra/base.rb#171
  def each; end

  # source://sinatra//lib/sinatra/base.rb#175
  def finish; end

  private

  # @return [Boolean]
  #
  # source://sinatra//lib/sinatra/base.rb#199
  def calculate_content_length?; end

  # @return [Boolean]
  #
  # source://sinatra//lib/sinatra/base.rb#207
  def drop_body?; end

  # @return [Boolean]
  #
  # source://sinatra//lib/sinatra/base.rb#203
  def drop_content_info?; end
end

# source://sinatra//lib/sinatra/base.rb#164
Sinatra::Response::DROP_BODY_RESPONSES = T.let(T.unsafe(nil), Array)

# Sinatra::ShowExceptions catches all exceptions raised from the app it
# wraps. It shows a useful backtrace with the sourcefile and clickable
# context, the whole Rack environment and the request data.
#
# Be careful when you use this on public-facing sites as it could reveal
# information helpful to attackers.
class Sinatra::ShowExceptions < ::Rack::ShowExceptions
  # @return [ShowExceptions] a new instance of ShowExceptions
  #
  # source://sinatra//lib/sinatra/show_exceptions.rb#18
  def initialize(app); end

  # source://sinatra//lib/sinatra/show_exceptions.rb#22
  def call(env); end

  # source://sinatra//lib/sinatra/show_exceptions.rb#48
  def template; end

  private

  # @return [Boolean]
  #
  # source://sinatra//lib/sinatra/show_exceptions.rb#54
  def bad_request?(exception); end

  # source://sinatra//lib/sinatra/show_exceptions.rb#63
  def frame_class(frame); end

  # @return [Boolean]
  #
  # source://sinatra//lib/sinatra/show_exceptions.rb#58
  def prefers_plain_text?(env); end
end

# source://sinatra//lib/sinatra/show_exceptions.rb#74
Sinatra::ShowExceptions::TEMPLATE = T.let(T.unsafe(nil), ERB)

# Template rendering methods. Each method takes the name of a template
# to render as a Symbol and returns a String with the rendered output,
# as well as an optional hash with additional options.
#
# `template` is either the name or path of the template as symbol
# (Use `:'subdir/myview'` for views in subdirectories), or a string
# that will be rendered.
#
# Possible options are:
#   :content_type   The content type to use, same arguments as content_type.
#   :layout         If set to something falsy, no layout is rendered, otherwise
#                   the specified layout is used
#   :layout_engine  Engine to use for rendering the layout.
#   :locals         A hash with local variables that should be available
#                   in the template
#   :scope          If set, template is evaluate with the binding of the given
#                   object rather than the application instance.
#   :views          Views directory to use.
module Sinatra::Templates
  # source://sinatra//lib/sinatra/base.rb#731
  def initialize; end

  # source://sinatra//lib/sinatra/base.rb#763
  def asciidoc(template, options = T.unsafe(nil), locals = T.unsafe(nil)); end

  # source://sinatra//lib/sinatra/base.rb#745
  def builder(template = T.unsafe(nil), options = T.unsafe(nil), locals = T.unsafe(nil), &block); end

  # source://sinatra//lib/sinatra/base.rb#737
  def erb(template, options = T.unsafe(nil), locals = T.unsafe(nil), &block); end

  # Calls the given block for every possible template file in views,
  # named name.ext, where ext is registered on engine.
  #
  # @yield [::File.join(views, "#{name}.#{@preferred_extension}")]
  #
  # source://sinatra//lib/sinatra/base.rb#792
  def find_template(views, name, engine); end

  # source://sinatra//lib/sinatra/base.rb#741
  def haml(template, options = T.unsafe(nil), locals = T.unsafe(nil), &block); end

  # source://sinatra//lib/sinatra/base.rb#750
  def liquid(template, options = T.unsafe(nil), locals = T.unsafe(nil), &block); end

  # source://sinatra//lib/sinatra/base.rb#767
  def markaby(template = T.unsafe(nil), options = T.unsafe(nil), locals = T.unsafe(nil), &block); end

  # source://sinatra//lib/sinatra/base.rb#754
  def markdown(template, options = T.unsafe(nil), locals = T.unsafe(nil)); end

  # source://sinatra//lib/sinatra/base.rb#771
  def nokogiri(template = T.unsafe(nil), options = T.unsafe(nil), locals = T.unsafe(nil), &block); end

  # source://sinatra//lib/sinatra/base.rb#785
  def rabl(template, options = T.unsafe(nil), locals = T.unsafe(nil)); end

  # source://sinatra//lib/sinatra/base.rb#759
  def rdoc(template, options = T.unsafe(nil), locals = T.unsafe(nil)); end

  # source://sinatra//lib/sinatra/base.rb#776
  def slim(template, options = T.unsafe(nil), locals = T.unsafe(nil), &block); end

  # source://sinatra//lib/sinatra/base.rb#780
  def yajl(template, options = T.unsafe(nil), locals = T.unsafe(nil)); end

  private

  # source://sinatra//lib/sinatra/base.rb#897
  def compile_block_template(template, options, &body); end

  # source://sinatra//lib/sinatra/base.rb#859
  def compile_template(engine, data, options, views); end

  # source://sinatra//lib/sinatra/base.rb#812
  def render(engine, data, options = T.unsafe(nil), locals = T.unsafe(nil), &block); end

  # logic shared between builder and nokogiri
  #
  # source://sinatra//lib/sinatra/base.rb#803
  def render_ruby(engine, template, options = T.unsafe(nil), locals = T.unsafe(nil), &block); end
end

module Sinatra::Templates::ContentTyped
  # Returns the value of attribute content_type.
  #
  # source://sinatra//lib/sinatra/base.rb#728
  def content_type; end

  # Sets the attribute content_type
  #
  # @param value the value to set the attribute content_type to.
  #
  # source://sinatra//lib/sinatra/base.rb#728
  def content_type=(_arg0); end
end

# source://sinatra//lib/sinatra/version.rb#4
Sinatra::VERSION = T.let(T.unsafe(nil), String)

class Sinatra::Wrapper
  # @return [Wrapper] a new instance of Wrapper
  #
  # source://sinatra//lib/sinatra/base.rb#1993
  def initialize(stack, instance); end

  # source://sinatra//lib/sinatra/base.rb#2006
  def call(env); end

  # source://sinatra//lib/sinatra/base.rb#2002
  def helpers; end

  # source://sinatra//lib/sinatra/base.rb#2010
  def inspect; end

  # source://sinatra//lib/sinatra/base.rb#1998
  def settings; end
end
